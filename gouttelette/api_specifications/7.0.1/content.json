{
    "swagger": "2.0",
    "info": {
        "description": "VMware vSphere\u00ae Content Library empowers vSphere Admins to effectively manage VM templates, vApps, ISO images and scripts with ease.",
        "title": "content",
        "version": "2.0.0"
    },
    "host": "<vcenter>",
    "securityDefinitions": {
        "basic_auth": {
            "type": "basic"
        }
    },
    "basePath": "",
    "produces": [
        "application/json"
    ],
    "consumes": [
        "application/json"
    ],
    "tags": [],
    "schemes": [
        "https",
        "http"
    ],
    "paths": {
        "/rest/com/vmware/content/configuration": {
            "patch": {
                "tags": [
                    "configuration"
                ],
                "summary": "Updates the configuration. The update is incremental. Any {@term field} in the {@link ConfigurationModel} {@term structure} that is {@term unset} will not be modified. Note that this update {@term operation} doesn't guarantee an atomic change of all the properties. In the case of a system crash or failure, some of the properties could be left unchanged while others may be updated.",
                "parameters": [
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.configuration_update"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "400": {
                        "description": "if one of the configuration properties is not within the proper range.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.invalid_argument_error"
                        }
                    }
                },
                "operationId": "update"
            }
        },
        "/rest/com/vmware/content/configuration?~action=get": {
            "post": {
                "tags": [
                    "configuration"
                ],
                "summary": "Retrieves the current configuration values.",
                "parameters": [],
                "responses": {
                    "200": {
                        "description": "The {@link ConfigurationModel} instance representing the configuration of the Content Library Service.",
                        "schema": {
                            "$ref": "#/definitions/content.configuration_resp"
                        }
                    }
                },
                "operationId": "get"
            }
        },
        "/rest/com/vmware/content/library": {
            "get": {
                "tags": [
                    "library"
                ],
                "summary": "Returns the identifiers of all libraries of any type in the Content Library.",
                "parameters": [],
                "responses": {
                    "200": {
                        "description": "The {@term list} of all identifiers of all libraries in the Content Library.",
                        "schema": {
                            "$ref": "#/definitions/content.library.list_resp"
                        }
                    }
                },
                "operationId": "list"
            }
        },
        "/rest/com/vmware/content/library/id:{library_id}": {
            "get": {
                "tags": [
                    "library"
                ],
                "summary": "Returns a given {@link LibraryModel}.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_id",
                        "description": "Identifier of the library to return."
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The {@link LibraryModel} instance with the specified {@param.name libraryId}.",
                        "schema": {
                            "$ref": "#/definitions/content.library_resp"
                        }
                    },
                    "404": {
                        "description": "if the specified library does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "get"
            },
            "patch": {
                "tags": [
                    "library"
                ],
                "summary": "Updates the properties of a library. <p> This is an incremental update to the library. Any {@term field} in the {@link LibraryModel} {@term structure} that is {@term unset} will not be modified. <p> This {@term operation} will only update the common properties for all library types. This will not, for example, update the {@link LibraryModel#publishInfo} of a local library, nor the {@link LibraryModel#subscriptionInfo} of a subscribed library. Specific properties are updated in {@link LocalLibrary#update} and {@link SubscribedLibrary#update}.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_id",
                        "description": "Identifier of the library to update."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library_update"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if the library associated with {@param.name libraryId} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the {@param.name updateSpec} is not valid.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.invalid_argument_error"
                        }
                    }
                },
                "operationId": "update"
            }
        },
        "/rest/com/vmware/content/library/item": {
            "get": {
                "tags": [
                    "library/item"
                ],
                "summary": "Returns the identifiers of all items in the given library.",
                "parameters": [
                    {
                        "type": "string",
                        "in": "query",
                        "name": "library_id",
                        "description": "Identifier of the library whose items should be returned.",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The {@term list} of identifiers of the items in the library specified by {@param.name libraryId}.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.list_resp"
                        }
                    },
                    "404": {
                        "description": "if the library associated with {@param.name libraryId} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "list"
            },
            "post": {
                "tags": [
                    "library/item"
                ],
                "summary": "Creates a new library item. <p> A new library item is created without any content. After creation, content can be added through the {@link UpdateSession} and {@link File} {@term services}. <p> A library item cannot be created in a subscribed library.",
                "parameters": [
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.item_create"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Identifier of the new library item.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.create_resp"
                        }
                    },
                    "404": {
                        "description": "if the {@link ItemModel#libraryId} property of {@param.name createSpec} refers to a library that does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if there is already a library item with same name in the library.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.already_exists_error"
                        }
                    }
                },
                "operationId": "create"
            }
        },
        "/rest/com/vmware/content/library/item/download-session": {
            "get": {
                "tags": [
                    "library/item/download_session"
                ],
                "summary": "Lists the identifiers of the download sessions created by the calling user. Optionally may filter by library item.",
                "parameters": [
                    {
                        "required": false,
                        "type": "string",
                        "in": "query",
                        "name": "library_item_id",
                        "description": "Library item identifier on which to filter results."
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The {@term list} of identifiers of all download sessions created by the calling user.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.download_session.list_resp"
                        }
                    },
                    "404": {
                        "description": "if a library item identifier is given for an item which does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "list"
            },
            "post": {
                "tags": [
                    "library/item/download_session"
                ],
                "summary": "Creates a new download session.",
                "parameters": [
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.item.download_session_create"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Identifier of the new download session being created.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.download_session.create_resp"
                        }
                    },
                    "400": {
                        "description": "if the session specification is not valid.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.invalid_argument_error"
                        }
                    },
                    "404": {
                        "description": "if the library item targeted by the download does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "create"
            }
        },
        "/rest/com/vmware/content/library/item/download-session/id:{download_session_id}": {
            "get": {
                "tags": [
                    "library/item/download_session"
                ],
                "summary": "Gets the download session with the specified identifier, including the most up-to-date status information for the session.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "download_session_id",
                        "description": "Identifier of the download session to retrieve."
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The {@link DownloadSessionModel} instance with the given {@param.name downloadSessionId}.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.download_session_resp"
                        }
                    },
                    "404": {
                        "description": "if no download session with the given {@param.name downloadSessionId} exists.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "get"
            },
            "delete": {
                "tags": [
                    "library/item/download_session"
                ],
                "summary": "Deletes a download session. This removes the session and all information associated with it. <p> Removing a download session leaves any current transfers for that session in an indeterminate state (there is no guarantee that the transfers will be able to complete). However there will no longer be a means of inspecting the status of those downloads except by seeing the effect on the library item. <p> Download sessions for which there is no download activity or which are complete will automatically be expired and then deleted after a period of time.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "download_session_id",
                        "description": "Identifier of the download session to be deleted."
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if the download session does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "delete"
            }
        },
        "/rest/com/vmware/content/library/item/download-session/id:{download_session_id}?~action=cancel": {
            "post": {
                "tags": [
                    "library/item/download_session"
                ],
                "summary": "Cancels the download session. This {@term operation} will abort any ongoing transfers and invalidate transfer urls that the client may be downloading from.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "download_session_id",
                        "description": "Identifer of the download session that should be canceled."
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if no download session with the given identifier exists.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the download session is not in the {@link DownloadSessionModel.State#ACTIVE} state.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    }
                },
                "operationId": "cancel"
            }
        },
        "/rest/com/vmware/content/library/item/download-session/id:{download_session_id}?~action=fail": {
            "post": {
                "tags": [
                    "library/item/download_session"
                ],
                "summary": "Terminates the download session with a client specified error message. <p> This is useful in transmitting client side failures (for example, not being able to download a file) to the server side.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "download_session_id",
                        "description": "Identifier of the download session to fail."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.item.download_session_fail"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if the download session does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the download session is not in the {@link DownloadSessionModel.State#ACTIVE} state.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    }
                },
                "operationId": "fail"
            }
        },
        "/rest/com/vmware/content/library/item/download-session/id:{download_session_id}?~action=keep-alive": {
            "post": {
                "tags": [
                    "library/item/download_session"
                ],
                "summary": "Keeps a download session alive. This operation is allowed only if the session is in the {@link DownloadSessionModel.State#ACTIVE} state. <p> If there is no activity for a download session for a certain period of time, the download session will expire. The download session expiration timeout is configurable in the Content Library Service system configuration. The default is five minutes. Invoking this {@term operation} enables a client to specifically extend the lifetime of an active download session.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "download_session_id",
                        "description": "Identifier of the download session whose lifetime should be extended."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.download_session_keep_alive"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if no download session with the given identifier exists.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the download session is not in the {@link DownloadSessionModel.State#ACTIVE} state.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    }
                },
                "operationId": "keep_alive"
            }
        },
        "/rest/com/vmware/content/library/item/downloadsession/file": {
            "get": {
                "tags": [
                    "library/item/downloadsession/file"
                ],
                "summary": "Lists the information of all the files in the library item associated with the download session.",
                "parameters": [
                    {
                        "type": "string",
                        "in": "query",
                        "name": "download_session_id",
                        "description": "Identifier of the download session.",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The {@term list} of {@link File.Info} instances.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.downloadsession.file.list_resp"
                        }
                    },
                    "404": {
                        "description": "if the download session associated with {@param.name downloadSessionId} doesn't exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "list"
            }
        },
        "/rest/com/vmware/content/library/item/downloadsession/file/id:{download_session_id}?~action=get": {
            "post": {
                "tags": [
                    "library/item/downloadsession/file"
                ],
                "summary": "Retrieves file download information for a specific file.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "download_session_id",
                        "description": "Identifier of the download session."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.item.downloadsession.file_get"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The {@link Info} instance containing the status of the file and its download link if available.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.downloadsession.file_resp"
                        }
                    },
                    "404": {
                        "description": "if the download session associated with {@param.name downloadSessionId} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if there is no file with the specified {@param.name fileName}.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.invalid_argument_error"
                        }
                    }
                },
                "operationId": "get"
            }
        },
        "/rest/com/vmware/content/library/item/downloadsession/file/id:{download_session_id}?~action=prepare": {
            "post": {
                "tags": [
                    "library/item/downloadsession/file"
                ],
                "summary": "Requests a file to be prepared for download.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "download_session_id",
                        "description": "Identifier of the download session."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.item.downloadsession.file_prepare"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "File information containing the status of the request and the download link to the file.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.downloadsession.file.prepare_resp"
                        }
                    },
                    "404": {
                        "description": "if the download session does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if there is no file with the specified {@param.name fileName}.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.invalid_argument_error"
                        }
                    },
                    "403": {
                        "description": "if the the download session wasn't created with the ContentLibrary.ReadStorage privilege and the caller requested a {@link EndpointType#DIRECT} endpoint type.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthorized_error"
                        }
                    }
                },
                "operationId": "prepare"
            }
        },
        "/rest/com/vmware/content/library/item/file": {
            "get": {
                "tags": [
                    "library/item/file"
                ],
                "summary": "Lists all of the files that are stored within a given library item.",
                "parameters": [
                    {
                        "type": "string",
                        "in": "query",
                        "name": "library_item_id",
                        "description": "Identifier of the library item whose files should be listed.",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The {@term list} of all of the files that are stored within the given library item.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.file.list_resp"
                        }
                    },
                    "404": {
                        "description": "if {@param.name libraryItemId} refers to a library item that does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "list"
            }
        },
        "/rest/com/vmware/content/library/item/file/id:{library_item_id}?~action=get": {
            "post": {
                "tags": [
                    "library/item/file"
                ],
                "summary": "Retrieves the information for a single file in a library item by its name.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_item_id",
                        "description": "Identifier of the library item whose file information should be returned."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.item.file_get"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The {@link Info} object with information on the specified file.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.file_resp"
                        }
                    },
                    "404": {
                        "description": "if {@param.name libraryItemId} refers to a library item that does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "get"
            }
        },
        "/rest/com/vmware/content/library/item/id:{library_item_id}": {
            "get": {
                "tags": [
                    "library/item"
                ],
                "summary": "Returns the {@link ItemModel} with the given identifier.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_item_id",
                        "description": "Identifier of the library item to return."
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The {@link ItemModel} instance with the given {@param.name libraryItemId}.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item_resp"
                        }
                    },
                    "404": {
                        "description": "if no item with the given {@param.name libraryItemId} exists.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "get"
            },
            "patch": {
                "tags": [
                    "library/item"
                ],
                "summary": "Updates the specified properties of a library item. <p> This is an incremental update to the library item. {@term Fields} that are {@term unset} in the update specification are left unchanged. <p> This {@term operation} cannot update a library item that is a member of a subscribed library. Those items must be updated in the source published library and synchronized to the subscribed library.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_item_id",
                        "description": "Identifier of the library item to update."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.item_update"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if the library item specified by {@param.name libraryItemId} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if there is already a library item with same name in the library.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.already_exists_error"
                        }
                    }
                },
                "operationId": "update"
            },
            "delete": {
                "tags": [
                    "library/item"
                ],
                "summary": "Deletes a library item. <p> This {@term operation} will immediately remove the item from the library that owns it. The content of the item will be asynchronously removed from the storage backings. The content deletion can be tracked with a task. In the event that the task fails, an administrator may need to manually remove the files from the storage backing. <p> This {@term operation} cannot be used to delete a library item that is a member of a subscribed library. Removing an item from a subscribed library requires deleting the item from the original published local library and syncing the subscribed library.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_item_id",
                        "description": "Identifier of the library item to delete."
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "400": {
                        "description": "if the library item contains a virtual machine template and a virtual machine is checked out of the library item.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    },
                    "404": {
                        "description": "if the library item with the specified {@param.name libraryItemId} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "delete"
            }
        },
        "/rest/com/vmware/content/library/item/id:{library_item_id}?~action=publish": {
            "post": {
                "tags": [
                    "library/item"
                ],
                "summary": "Publishes the library item to specified subscriptions of the library. If no subscriptions are specified, then publishes the library item to all subscriptions of the library.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_item_id",
                        "description": "Library item identifier."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.item_publish"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "400": {
                        "description": "If the library item specified by {@param.name libraryItemId} does not belong to a published library.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    },
                    "404": {
                        "description": "If the library item specified by {@param.name libraryItemId} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "401": {
                        "description": "If the user that requested the {@term operation} cannot be authenticated.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthenticated_error"
                        }
                    },
                    "403": {
                        "description": "If the user that requested the {@term operation} is not authorized to perform the {@term operation}.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthorized_error"
                        }
                    }
                },
                "operationId": "publish"
            }
        },
        "/rest/com/vmware/content/library/item/id:{source_library_item_id}?~action=copy": {
            "post": {
                "tags": [
                    "library/item"
                ],
                "summary": "Copies a library item. <p> Copying a library item allows a duplicate to be made within the same or different library. The copy occurs by first creating a new library item, whose identifier is returned. The content of the library item is then copied asynchronously. This copy can be tracked as a task. <p> If the copy fails, Content Library Service will roll back the copy by deleting any content that was already copied, and removing the new library item. A failure during rollback may require manual cleanup by an administrator. <p> A library item cannot be copied into a subscribed library.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "source_library_item_id",
                        "description": "Identifier of the existing library item from which the content will be copied."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.item_copy"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The identifier of the new library item into which the content is being copied.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.copy_resp"
                        }
                    },
                    "404": {
                        "description": "if the library item with {@param.name sourceLibraryItemId} does not exist, or if the library referenced by the {@link ItemModel#libraryId} property of {@param.name destinationCreateSpec} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the content of the source library item specified by {@param.name sourceLibraryItemId}, or the content of the target library specified by the library ID (see {@link ItemModel#libraryId}) property of {@param.name destinationCreateSpec} has been deleted from the storage backings (see {@link LibraryModel#storageBackings}) associated with it.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    }
                },
                "operationId": "copy"
            }
        },
        "/rest/com/vmware/content/library/item/storage": {
            "get": {
                "tags": [
                    "library/item/storage"
                ],
                "summary": "Lists all storage items for a given library item.",
                "parameters": [
                    {
                        "type": "string",
                        "in": "query",
                        "name": "library_item_id",
                        "description": "Identifier of the library item whose storage information should be listed.",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The {@term list} of all storage items for a given library item.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.storage.list_resp"
                        }
                    },
                    "404": {
                        "description": "if the specified library item does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "list"
            }
        },
        "/rest/com/vmware/content/library/item/storage/id:{library_item_id}?~action=get": {
            "post": {
                "tags": [
                    "library/item/storage"
                ],
                "summary": "Retrieves the storage information for a specific file in a library item.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_item_id",
                        "description": "Identifier of the library item whose storage information should be retrieved."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.item.storage_get"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The {@term list} of all the storage items for the given file within the given library item.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.storage_resp"
                        }
                    },
                    "404": {
                        "description": "if the specified library item does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "get"
            }
        },
        "/rest/com/vmware/content/library/item/update-session": {
            "get": {
                "tags": [
                    "library/item/update_session"
                ],
                "summary": "Lists the identifiers of the update session created by the calling user. Optionally may filter by library item.",
                "parameters": [
                    {
                        "required": false,
                        "type": "string",
                        "in": "query",
                        "name": "library_item_id",
                        "description": "Optional library item identifier on which to filter results."
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The {@term list} of identifiers of all update sessions created by the calling user.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.update_session.list_resp"
                        }
                    },
                    "404": {
                        "description": "if a library item identifier is given for an item which does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "list"
            },
            "post": {
                "tags": [
                    "library/item/update_session"
                ],
                "summary": "Creates a new update session. An update session is used to make modifications to a library item. Modifications are not visible to other clients unless the session is completed and all necessary files have been received. <p> Content Library Service allows only one single update session to be active for a specific library item.",
                "parameters": [
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.item.update_session_create"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Identifier of the new update session being created.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.update_session.create_resp"
                        }
                    },
                    "400": {
                        "description": "if there is another update session on the same library item.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.resource_busy_error"
                        }
                    },
                    "404": {
                        "description": "if the item targeted for update does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "create"
            }
        },
        "/rest/com/vmware/content/library/item/update-session/id:{update_session_id}": {
            "get": {
                "tags": [
                    "library/item/update_session"
                ],
                "summary": "Gets the update session with the specified identifier, including the most up-to-date status information for the session.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "update_session_id",
                        "description": "Identifier of the update session to retrieve."
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The {@link UpdateSessionModel} instance with the given {@param.name updateSessionId}.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.update_session_resp"
                        }
                    },
                    "404": {
                        "description": "if no update session with the given identifier exists.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "get"
            },
            "patch": {
                "tags": [
                    "library/item/update_session"
                ],
                "summary": "Updates the properties of an update session. <p> This is an incremental update to the update session. Any {@term field} in the {@link UpdateSessionModel} {@term structure} that is {@term unset} will not be modified. <p> This {@term operation} will only update the property {@link UpdateSessionModel#warningBehavior} of the update session. This will not, for example, update the {@link UpdateSessionModel#libraryItemId} or {@link UpdateSessionModel#state} of an update session. <p> This {@term operation} requires the session to be in the {@link UpdateSessionModel.State#ACTIVE} state.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "update_session_id",
                        "description": "Identifer of the update session that should be updated."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.item.update_session_update"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if the update session does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the update session specification is not valid.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.invalid_argument_error"
                        }
                    }
                },
                "operationId": "update"
            },
            "delete": {
                "tags": [
                    "library/item/update_session"
                ],
                "summary": "Deletes an update session. This removes the session and all information associated with it. <p> Removing an update session leaves any current transfers for that session in an indeterminate state (there is no guarantee that the server will terminate the transfers, or that the transfers can be completed). However there will no longer be a means of inspecting the status of those uploads except by seeing the effect on the library item. <p> Update sessions for which there is no upload activity or which are complete will automatically be deleted after a period of time.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "update_session_id",
                        "description": "Identifer of the update session to delete."
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if the update session does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the update session is in the {@link UpdateSessionModel.State#ACTIVE} state.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    }
                },
                "operationId": "delete"
            }
        },
        "/rest/com/vmware/content/library/item/update-session/id:{update_session_id}?~action=cancel": {
            "post": {
                "tags": [
                    "library/item/update_session"
                ],
                "summary": "Cancels the update session and sets its state to {@link UpdateSessionModel.State#CANCELED}. This {@term operation} will free up any temporary resources currently associated with the session. <p> This {@term operation} is not allowed if the session has been already completed. <p> Cancelling an update session will cancel any in progress transfers (either uploaded by the client or pulled by the server). Any content that has been already received will be scheduled for deletion.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "update_session_id",
                        "description": "Identifier of the update session that should be canceled."
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if no update session with the given identifier exists.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the update session is not in the {@link UpdateSessionModel.State#ACTIVE} state.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    }
                },
                "operationId": "cancel"
            }
        },
        "/rest/com/vmware/content/library/item/update-session/id:{update_session_id}?~action=complete": {
            "post": {
                "tags": [
                    "library/item/update_session"
                ],
                "summary": "Completes the update session. This indicates that the client has finished making all the changes required to the underlying library item. If the client is pushing the content to the server, the library item will be updated once this call returns. If the server is pulling the content, the call may return before the changes become visible. In that case, the client can track the session to know when the server is done. <p> This {@term operation} requires the session to be in the {@link UpdateSessionModel.State#ACTIVE} state. <p> Depending on the type of the library item associated with this session, a type adapter may be invoked to verify the validity of the files uploaded. The user can explicitly validate the session before completing the session by using the {@link content.library.item.updatesession.File#validate} {@term operation}. <p> Modifications are not visible to other clients unless the session is completed and all necessary files have been received.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "update_session_id",
                        "description": "Identifier of the update session that should be completed."
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if no update session with the given identifier exists.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the update session is not in the {@link UpdateSessionModel.State#ACTIVE} state, or if some of the files that will be uploaded by the client aren't received correctly.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    }
                },
                "operationId": "complete"
            }
        },
        "/rest/com/vmware/content/library/item/update-session/id:{update_session_id}?~action=fail": {
            "post": {
                "tags": [
                    "library/item/update_session"
                ],
                "summary": "Terminates the update session with a client specified error message. <p> This is useful in transmitting client side failures (for example, not being able to access a file) to the server side.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "update_session_id",
                        "description": "Identifier of the update session to fail."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.item.update_session_fail"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if the update session does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the update session is not in the {@link UpdateSessionModel.State#ACTIVE} state.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    }
                },
                "operationId": "fail"
            }
        },
        "/rest/com/vmware/content/library/item/update-session/id:{update_session_id}?~action=keep-alive": {
            "post": {
                "tags": [
                    "library/item/update_session"
                ],
                "summary": "Keeps an update session alive. <p> If there is no activity for an update session after a period of time, the update session will expire, then be deleted. The update session expiration timeout is configurable in the Content Library Service system configuration. The default is five minutes. Invoking this {@term operation} enables a client to specifically extend the lifetime of the update session.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "update_session_id",
                        "description": "Identifier of the update session whose lifetime should be extended."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.update_session_keep_alive"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if no update session with the given identifier exists.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the update session is not in the {@link UpdateSessionModel.State#ACTIVE} state.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    }
                },
                "operationId": "keep_alive"
            }
        },
        "/rest/com/vmware/content/library/item/updatesession/file": {
            "get": {
                "tags": [
                    "library/item/updatesession/file"
                ],
                "summary": "Lists all files in the library item associated with the update session.",
                "parameters": [
                    {
                        "type": "string",
                        "in": "query",
                        "name": "update_session_id",
                        "description": "Identifier of the update session.",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The {@term list} of the files in the library item associated with the update session. This {@term list} may be empty if the caller has removed all the files as part of this session (in which case completing the update session will result in an empty library item).",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.updatesession.file.list_resp"
                        }
                    },
                    "404": {
                        "description": "if the update session doesn't exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "list"
            }
        },
        "/rest/com/vmware/content/library/item/updatesession/file/id:{update_session_id}?~action=add": {
            "post": {
                "tags": [
                    "library/item/updatesession/file"
                ],
                "summary": "Requests file content to be changed (either created, or updated). Depending on the source type of the file, this {@term operation} will either return an upload endpoint where the client can push the content, or the server will pull from the provided source endpoint. If a file with the same name already exists in this session, this {@term operation} will be used to update the content of the existing file. <p> When importing a file directly from storage, where the source endpoint is a file or datastore URI, you will need to have the ContentLibrary.ReadStorage privilege on the library item. If the file is located in the same directory as the library storage backing folder, the server will move the file instead of copying it, thereby allowing instantaneous import of files for efficient backup and restore scenarios. In all other cases, a copy is performed rather than a move.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "update_session_id",
                        "description": "Identifier of the update session to be modified."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.item.updatesession.file_add"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "An {@link Info} {@term structure} containing upload links as well as server side state tracking the transfer of the file.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.updatesession.file.add_resp"
                        }
                    },
                    "400": {
                        "description": "if the content of the library item associated with the update session has been deleted from the storage backings (see {@link LibraryModel#storageBackings}) associated with it.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    },
                    "404": {
                        "description": "if the update session doesn't exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "403": {
                        "description": "if the caller doesn't have ContentLibrary.ReadStorage privilege on the library item of the update session and source type {@link SourceType#PULL} is requested for a file or datastore source endpoint (that is, not HTTP or HTTPs based endpoint).",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthorized_error"
                        }
                    }
                },
                "operationId": "add"
            }
        },
        "/rest/com/vmware/content/library/item/updatesession/file/id:{update_session_id}?~action=get": {
            "post": {
                "tags": [
                    "library/item/updatesession/file"
                ],
                "summary": "Retrieves information about a specific file in the snapshot of the library item at the time when the update session was created.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "update_session_id",
                        "description": "Identifier of the update session."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.item.updatesession.file_get"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Information about the file.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.updatesession.file_resp"
                        }
                    },
                    "404": {
                        "description": "if the update session doesn't exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the file doesn't exist in the library item associated with the update session.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.invalid_argument_error"
                        }
                    }
                },
                "operationId": "get"
            }
        },
        "/rest/com/vmware/content/library/item/updatesession/file/id:{update_session_id}?~action=remove": {
            "post": {
                "tags": [
                    "library/item/updatesession/file"
                ],
                "summary": "Requests a file to be removed. The file will only be effectively removed when the update session is completed.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "update_session_id",
                        "description": "Identifier of the update session."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.item.updatesession.file_remove"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if the update session doesn't exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the file doesn't exist in the library item associated with the update session.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.invalid_argument_error"
                        }
                    }
                },
                "operationId": "remove"
            }
        },
        "/rest/com/vmware/content/library/item/updatesession/file/id:{update_session_id}?~action=validate": {
            "post": {
                "tags": [
                    "library/item/updatesession/file"
                ],
                "summary": "Validates the files in the update session with the referenced identifier and ensures all necessary files are received. In the case where a file is missing, this {@term operation} will return its name in the {@link ValidationResult#missingFiles} set. The user can add the missing files and try re-validating. For other type of errors, {@link ValidationResult#invalidFiles} will contain the list of invalid files.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "update_session_id",
                        "description": "Identifier of the update session to validate."
                    }
                ],
                "responses": {
                    "200": {
                        "description": "A validation result containing missing files or invalid files and the reason why they are invalid.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.updatesession.file.validate_resp"
                        }
                    },
                    "404": {
                        "description": "if no update session with the given identifier exists.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the update session is not in the {@link UpdateSessionModel.State#ACTIVE} state, or if some of the files that will be uploaded by the client aren't received correctly.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    }
                },
                "operationId": "validate"
            }
        },
        "/rest/com/vmware/content/library/item?~action=find": {
            "post": {
                "tags": [
                    "library/item"
                ],
                "summary": "Returns identifiers of all the visible (as determined by authorization policy) library items matching the requested {@link Item.FindSpec}.",
                "parameters": [
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.item_find"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The {@term list} of identifiers of all the visible library items matching the given {@param.name spec}.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.find_resp"
                        }
                    },
                    "400": {
                        "description": "if no properties are specified in the {@param.name spec}.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.invalid_argument_error"
                        }
                    }
                },
                "operationId": "find"
            }
        },
        "/rest/com/vmware/content/library/subscribed-item/id:{library_item_id}?~action=evict": {
            "post": {
                "tags": [
                    "library/subscribed_item"
                ],
                "summary": "Evicts the cached content of a library item in a subscribed library. <p> This {@term operation} allows the cached content of a library item to be removed to free up storage capacity. This {@term operation} will only work when a library item is synchronized on-demand. When a library is not synchronized on-demand, it always attempts to keep its cache up-to-date with the published source. Evicting the library item will set {@link ItemModel#cached} to false.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_item_id",
                        "description": "Identifier of the library item whose content should be evicted."
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if the library item specified by {@param.name libraryItemId} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the content of the library item specified by {@param.name libraryItemId} has been deleted from the storage backings (see {@link LibraryModel#storageBackings}) associated with it. <p> For instance, this {@term error) is reported on evicting a library item in an on-demand subscribed library that was restored from backup, and the library item was deleted after backup, thus resulting in its content being deleted from the associated storage backings. In this scenario, the metadata of the library item is present on a restore, while its content has been deleted.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    }
                },
                "operationId": "evict"
            }
        },
        "/rest/com/vmware/content/library/subscribed-item/id:{library_item_id}?~action=sync": {
            "post": {
                "tags": [
                    "library/subscribed_item"
                ],
                "summary": "Forces the synchronization of an individual library item in a subscribed library. <p> Synchronizing an individual item will update that item's metadata from the remote source. If the source library item on the remote library has been deleted, this {@term operation} will delete the library item from the subscribed library as well. <p> The default behavior of the synchronization is determined by the {@link SubscriptionInfo} of the library which owns the library item. <ul> <li>If {@link SubscriptionInfo#onDemand} is true, then the file content is not synchronized by default. In this case, only the library item metadata is synchronized. The file content may still be forcefully synchronized by passing true for the {@param.name forceSyncContent} {@term parameter}.</li> <li>If {@link SubscriptionInfo#onDemand} is false, then this call will always synchronize the file content. The {@param.name forceSyncContent} {@term parameter} is ignored when the subscription is not on-demand.</li> </ul> When the file content has been synchronized, the {@link ItemModel#cached} {@term field} will be true. <p> This {@term operation} will return immediately and create an asynchronous task to perform the synchronization.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_item_id",
                        "description": "Identifier of the library item to synchronize."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.subscribed_item_sync"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if the library item specified by {@param.name libraryItemId} could not be found.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the content of the library item specified by {@param.name libraryItemId} has been deleted from the storage backings (see {@link LibraryModel#storageBackings}) associated with it. <p> For instance, this {@term error) is reported on synchronizing a library item in a subscribed library that was restored from backup, and the library item was deleted after backup, thus resulting in its content being deleted from the associated storage backings. In this scenario, the metadata of the library item is present on a restore, while its content has been deleted.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    }
                },
                "operationId": "sync"
            }
        },
        "/rest/com/vmware/content/library/subscriptions": {
            "get": {
                "tags": [
                    "library/subscriptions"
                ],
                "summary": "Lists the subscriptions of the published library.",
                "parameters": [
                    {
                        "type": "string",
                        "in": "query",
                        "name": "library",
                        "description": "Identifier of the published library.",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of commonly used information about subscriptions of the published library.",
                        "schema": {
                            "$ref": "#/definitions/content.library.subscriptions.list_resp"
                        }
                    },
                    "400": {
                        "description": "If the library specified by {@param.name library} is not a published library.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    },
                    "404": {
                        "description": "If the library specified by {@param.name library} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "401": {
                        "description": "If the user that requested the {@term operation} cannot be authenticated.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthenticated_error"
                        }
                    },
                    "403": {
                        "description": "If the user that requested the {@term operation} is not authorized to perform the {@term operation}.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthorized_error"
                        }
                    }
                },
                "operationId": "list"
            }
        },
        "/rest/com/vmware/content/library/subscriptions/id:{library}": {
            "patch": {
                "tags": [
                    "library/subscriptions"
                ],
                "summary": "Updates the specified subscription of the published library. <p> This is an incremental update to the subscription. Except for the {@link UpdateSpecPlacement} {@term structure}, {@term fields} that are {@term unset} in the update specification will be left unchanged. If {@param.name spec#subscribedLibraryPlacement} is specified, all {@term fields} of the current subscribed library placement will be replaced by this placement.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library",
                        "description": "Identifier of the published library."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.subscriptions_update"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "400": {
                        "description": "If the library specified by {@param.name library} is not a published library.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    },
                    "404": {
                        "description": "If the library specified by {@param.name library} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "401": {
                        "description": "If the user that requested the {@term operation} cannot be authenticated.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthenticated_error"
                        }
                    },
                    "403": {
                        "description": "If the user that requested the {@term operation} is not authorized to perform the {@term operation}.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthorized_error"
                        }
                    }
                },
                "operationId": "update"
            },
            "post": {
                "tags": [
                    "library/subscriptions"
                ],
                "summary": "Creates a subscription of the published library.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library",
                        "description": "Identifier of the published library."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.subscriptions_create"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Subscription identifier.",
                        "schema": {
                            "$ref": "#/definitions/content.library.subscriptions.create_resp"
                        }
                    },
                    "400": {
                        "description": "If the library specified by {@param.name library} is not a published library.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    },
                    "404": {
                        "description": "If the library specified by {@param.name library} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "401": {
                        "description": "If the user that requested the {@term operation} cannot be authenticated.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthenticated_error"
                        }
                    },
                    "403": {
                        "description": "If the user that requested the {@term operation} is not authorized to perform the {@term operation}.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthorized_error"
                        }
                    }
                },
                "operationId": "create"
            }
        },
        "/rest/com/vmware/content/library/subscriptions/id:{library}?~action=delete": {
            "post": {
                "tags": [
                    "library/subscriptions"
                ],
                "summary": "Deletes the specified subscription of the published library. The subscribed library associated with the subscription will not be deleted.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library",
                        "description": "Identifier of the published library."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.subscriptions_delete"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "400": {
                        "description": "If the library specified by {@param.name library} is not a published library.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    },
                    "404": {
                        "description": "If the library specified by {@param.name library} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "401": {
                        "description": "If the user that requested the {@term operation} cannot be authenticated.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthenticated_error"
                        }
                    },
                    "403": {
                        "description": "If the user that requested the {@term operation} is not authorized to perform the {@term operation}.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthorized_error"
                        }
                    }
                },
                "operationId": "delete"
            }
        },
        "/rest/com/vmware/content/library/subscriptions/id:{library}?~action=get": {
            "post": {
                "tags": [
                    "library/subscriptions"
                ],
                "summary": "Returns information about the specified subscription of the published library.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library",
                        "description": "Identifier of the published library."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library.subscriptions_get"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Information about the subscription.",
                        "schema": {
                            "$ref": "#/definitions/content.library.subscriptions_resp"
                        }
                    },
                    "400": {
                        "description": "If the library specified by {@param.name library} is not a published library.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    },
                    "404": {
                        "description": "If the library specified by {@param.name library} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "401": {
                        "description": "If the user that requested the {@term operation} cannot be authenticated.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthenticated_error"
                        }
                    },
                    "403": {
                        "description": "If the user that requested the {@term operation} is not authorized to perform the {@term operation}.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthorized_error"
                        }
                    }
                },
                "operationId": "get"
            }
        },
        "/rest/com/vmware/content/library?~action=find": {
            "post": {
                "tags": [
                    "library"
                ],
                "summary": "Returns a list of all the visible (as determined by authorization policy) libraries matching the requested {@link Library.FindSpec}.",
                "parameters": [
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.library_find"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The {@term list} of identifiers of all the visible libraries matching the given {@param.name spec}.",
                        "schema": {
                            "$ref": "#/definitions/content.library.find_resp"
                        }
                    },
                    "400": {
                        "description": "if no properties are specified in the {@param.name spec}.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.invalid_argument_error"
                        }
                    }
                },
                "operationId": "find"
            }
        },
        "/rest/com/vmware/content/local-library": {
            "get": {
                "tags": [
                    "local_library"
                ],
                "summary": "Returns the identifiers of all local libraries in the Content Library.",
                "parameters": [],
                "responses": {
                    "200": {
                        "description": "The {@term list} of identifiers of all local libraries in the Content Library.",
                        "schema": {
                            "$ref": "#/definitions/content.local_library.list_resp"
                        }
                    }
                },
                "operationId": "list"
            },
            "post": {
                "tags": [
                    "local_library"
                ],
                "summary": "Creates a new local library.",
                "parameters": [
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.local_library_create"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Identifier of the newly created {@link LibraryModel}.",
                        "schema": {
                            "$ref": "#/definitions/content.local_library.create_resp"
                        }
                    },
                    "400": {
                        "description": "if using multiple storage backings.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unsupported_error"
                        }
                    }
                },
                "operationId": "create"
            }
        },
        "/rest/com/vmware/content/local-library/id:{library_id}": {
            "get": {
                "tags": [
                    "local_library"
                ],
                "summary": "Returns a given local library.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_id",
                        "description": "Identifier of the local library to return."
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The {@link LibraryModel} instance associated with {@param.name libraryId}.",
                        "schema": {
                            "$ref": "#/definitions/content.local_library_resp"
                        }
                    },
                    "404": {
                        "description": "if the library specified by {@param.name libraryId} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the library specified by {@param.name libraryId} is not a local library.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.invalid_element_type_error"
                        }
                    }
                },
                "operationId": "get"
            },
            "patch": {
                "tags": [
                    "local_library"
                ],
                "summary": "Updates the properties of a local library. <p> This is an incremental update to the local library. {@term Fields} that are {@term unset} in the update specification will be left unchanged.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_id",
                        "description": "Identifier of the local library to update."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.local_library_update"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if the library specified by {@param.name libraryId} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the {@link LibraryModel#version} of {@param.name updateSpec} is not equal to the current version of the library.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.concurrent_change_error"
                        }
                    }
                },
                "operationId": "update"
            },
            "delete": {
                "tags": [
                    "local_library"
                ],
                "summary": "Deletes the specified local library. <p> Deleting a local library will remove the entry immediately and begin an asynchronous task to remove all cached content for the library. If the asynchronous task fails, file content may remain on the storage backing. This content will require manual removal.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_id",
                        "description": "Identifier of the local library to delete."
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "400": {
                        "description": "if the library contains a library item that cannot be deleted in its current state. For example, the library item contains a virtual machine template and a virtual machine is checked out of the library item.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    },
                    "404": {
                        "description": "if the library specified by {@param.name libraryId} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "delete"
            }
        },
        "/rest/com/vmware/content/local-library/id:{library_id}?~action=publish": {
            "post": {
                "tags": [
                    "local_library"
                ],
                "summary": "Publishes the library to specified subscriptions. If no subscriptions are specified, then publishes the library to all its subscriptions.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_id",
                        "description": "Identifier of the published library."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "schema": {
                            "$ref": "#/definitions/content.local_library_publish"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "400": {
                        "description": "If the library specified by {@param.name libraryId} is not a published library.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    },
                    "404": {
                        "description": "If the library specified by {@param.name libraryId} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "401": {
                        "description": "If the user that requested the {@term operation} cannot be authenticated.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthenticated_error"
                        }
                    },
                    "403": {
                        "description": "If the user that requested the {@term operation} is not authorized to perform the {@term operation}.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthorized_error"
                        }
                    }
                },
                "operationId": "publish"
            }
        },
        "/rest/com/vmware/content/subscribed-library": {
            "post": {
                "tags": [
                    "subscribed_library"
                ],
                "summary": "Creates a new subscribed library. <p> Once created, the subscribed library will be empty. If the {@link LibraryModel#subscriptionInfo} property is set, the Content Library Service will attempt to synchronize to the remote source. This is an asynchronous operation so the content of the published library may not immediately appear.",
                "parameters": [
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.subscribed_library_create"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Identifier of the newly created subscribed library.",
                        "schema": {
                            "$ref": "#/definitions/content.subscribed_library.create_resp"
                        }
                    },
                    "400": {
                        "description": "if subscribing to a published library which cannot be accessed.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.resource_inaccessible_error"
                        }
                    }
                },
                "operationId": "create"
            },
            "get": {
                "tags": [
                    "subscribed_library"
                ],
                "summary": "Returns the identifiers of all subscribed libraries in the Content Library.",
                "parameters": [],
                "responses": {
                    "200": {
                        "description": "The {@term list} of identifiers of all subscribed libraries in the Content Library.",
                        "schema": {
                            "$ref": "#/definitions/content.subscribed_library.list_resp"
                        }
                    }
                },
                "operationId": "list"
            }
        },
        "/rest/com/vmware/content/subscribed-library/id:{library_id}": {
            "patch": {
                "tags": [
                    "subscribed_library"
                ],
                "summary": "Updates the properties of a subscribed library. <p> This is an incremental update to the subscribed library. {@term Fields} that are {@term unset} in the update specification will be left unchanged.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_id",
                        "description": "Identifier of the subscribed library to update."
                    },
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.subscribed_library_update"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if the library specified by {@param.name libraryId} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the {@link LibraryModel#version} of {@param.name updateSpec} is not equal to the current version of the library.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.concurrent_change_error"
                        }
                    }
                },
                "operationId": "update"
            },
            "delete": {
                "tags": [
                    "subscribed_library"
                ],
                "summary": "Deletes the specified subscribed library. <p> Deleting a subscribed library will remove the entry immediately and begin an asynchronous task to remove all cached content for the library. If the asynchronous task fails, file content may remain on the storage backing. This content will require manual removal.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_id",
                        "description": "Identifier of the subscribed library to delete."
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "400": {
                        "description": "if the library referenced by {@param.name libraryId} is not a subscribed library.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.invalid_element_type_error"
                        }
                    },
                    "404": {
                        "description": "if the library referenced by {@param.name libraryId} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    }
                },
                "operationId": "delete"
            },
            "get": {
                "tags": [
                    "subscribed_library"
                ],
                "summary": "Returns a given subscribed library.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_id",
                        "description": "Identifier of the subscribed library to return."
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The {@link LibraryModel} instance that corresponds to {@param.name libraryId}.",
                        "schema": {
                            "$ref": "#/definitions/content.subscribed_library_resp"
                        }
                    },
                    "404": {
                        "description": "if the library associated with {@param.name libraryId} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the library associated with {@param.name libraryId} is not a subscribed library.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.invalid_element_type_error"
                        }
                    }
                },
                "operationId": "get"
            }
        },
        "/rest/com/vmware/content/subscribed-library/id:{library_id}?~action=evict": {
            "post": {
                "tags": [
                    "subscribed_library"
                ],
                "summary": "Evicts the cached content of an on-demand subscribed library. <p> This {@term operation} allows the cached content of a subscribed library to be removed to free up storage capacity. This {@term operation} will only work when a subscribed library is synchronized on-demand.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_id",
                        "description": "Identifier of the subscribed library whose content should be evicted."
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if the library specified by {@param.name libraryId} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the library specified by {@param.name libraryId} does not synchronize on-demand, or if the content of the library specified by {@param.name libraryId} has been deleted from the storage backings (see {@link LibraryModel#storageBackings}) associated with it. <p> For instance, this {@term error) is reported on evicting an on-demand subscribed library that was restored from backup, and the library was deleted after the backup was taken, thus resulting in its content being deleted from the associated storage backings. In this scenario, the metadata of the library is present on a restore, while its content has been deleted.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state_error"
                        }
                    }
                },
                "operationId": "evict"
            }
        },
        "/rest/com/vmware/content/subscribed-library/id:{library_id}?~action=sync": {
            "post": {
                "tags": [
                    "subscribed_library"
                ],
                "summary": "Forces the synchronization of the subscribed library. <p> Synchronizing a subscribed library forcefully with this {@term operation} will perform the same synchronization behavior as would run periodically for the library. The {@link SubscriptionInfo#onDemand} setting is respected. Calling this {@term operation} on a library that is already in the process of synchronizing will have no effect.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_id",
                        "description": "Identifier of the subscribed library to synchronize."
                    }
                ],
                "responses": {
                    "200": {
                        "description": ""
                    },
                    "404": {
                        "description": "if the library specified by {@param.name libraryId} does not exist.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "400": {
                        "description": "if the published library cannot be contacted or found.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.resource_inaccessible_error"
                        }
                    }
                },
                "operationId": "sync"
            }
        },
        "/rest/com/vmware/content/subscribed-library?~action=probe": {
            "post": {
                "tags": [
                    "subscribed_library"
                ],
                "summary": "Probes remote library subscription information, including URL, SSL certificate and password. The resulting {@link ProbeResult} {@term structure} describes whether or not the subscription configuration is successful.",
                "parameters": [
                    {
                        "in": "body",
                        "name": "request_body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/content.subscribed_library_probe"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The subscription info probe result.",
                        "schema": {
                            "$ref": "#/definitions/content.subscribed_library.probe_resp"
                        }
                    }
                },
                "operationId": "probe"
            }
        },
        "/rest/com/vmware/content/type": {
            "get": {
                "tags": [
                    "type"
                ],
                "summary": "Returns a {@term list} of {@link Info} instances which describe the type support plugins in this Content Library.",
                "parameters": [],
                "responses": {
                    "200": {
                        "description": "The {@term list} of {@link Info} instances which describe the type support plugins in this Content Library.",
                        "schema": {
                            "$ref": "#/definitions/content.type.list_resp"
                        }
                    }
                },
                "operationId": "list"
            }
        },
        "/rest/content/library/item/{library_item}/changes": {
            "get": {
                "tags": [
                    "library/item/changes"
                ],
                "summary": "Returns commonly used information about the content changes made to a library item.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_item",
                        "description": "Library item identifier."
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of commonly used information about the library item changes.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.changes.list_resp"
                        }
                    },
                    "404": {
                        "description": "if the library item is not found.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "401": {
                        "description": "if the user that requested the {@term operation} cannot be authenticated.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthenticated_error"
                        }
                    },
                    "403": {
                        "description": "if the user that requested the {@term operation} is not authorized to perform the {@term operation}.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthorized_error"
                        }
                    },
                    "400": {
                        "description": "if the system reports an error while responding to the request.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.error_error"
                        }
                    }
                },
                "operationId": "list"
            }
        },
        "/rest/content/library/item/{library_item}/changes/{version}": {
            "get": {
                "tags": [
                    "library/item/changes"
                ],
                "summary": "Returns information about a library item change.",
                "parameters": [
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "library_item",
                        "description": "Library item identifer."
                    },
                    {
                        "type": "string",
                        "required": true,
                        "in": "path",
                        "name": "version",
                        "description": "Library item version."
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Information about the specified library item change.",
                        "schema": {
                            "$ref": "#/definitions/content.library.item.changes_resp"
                        }
                    },
                    "404": {
                        "description": "if the library item or version is not found.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.not_found_error"
                        }
                    },
                    "401": {
                        "description": "if the user that requested the {@term operation} cannot be authenticated.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthenticated_error"
                        }
                    },
                    "403": {
                        "description": "if the user that requested the {@term operation} is not authorized to perform the {@term operation}.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.unauthorized_error"
                        }
                    },
                    "400": {
                        "description": "if the system reports an error while responding to the request.",
                        "schema": {
                            "$ref": "#/definitions/vapi.std.errors.error_error"
                        }
                    }
                },
                "operationId": "get"
            }
        }
    },
    "definitions": {
        "content.configuration_model": {
            "type": "object",
            "properties": {
                "automatic_sync_enabled": {
                    "description": "Whether automatic synchronization is enabled. <p> When automatic synchronization is enabled, the Content Library Service will automatically synchronize all subscribed libraries on a daily basis. Subscribed libraries with the {@link SubscriptionInfo#automaticSyncEnabled} flag turned on will be synchronized every hour between {@link #automaticSyncStartHour} and {@link #automaticSyncStopHour}.",
                    "type": "boolean"
                },
                "automatic_sync_start_hour": {
                    "description": "The hour at which the automatic synchronization will start. This value is between 0 (midnight) and 23 inclusive.",
                    "type": "integer",
                    "format": "int64"
                },
                "automatic_sync_stop_hour": {
                    "description": "The hour at which the automatic synchronization will stop. Any active synchronization operation will continue to run, however no new synchronization operations will be triggered after the stop hour. This value is between 0 (midnight) and 23 inclusive.",
                    "type": "integer",
                    "format": "int64"
                },
                "maximum_concurrent_item_syncs": {
                    "description": "The maximum allowed number of library items to synchronize concurrently from remote libraries. This must be a positive number. The service may not be able to guarantee the requested concurrency if there is no available capacity. <p> This setting is global across all subscribed libraries.",
                    "type": "integer",
                    "format": "int64"
                }
            }
        },
        "content.configuration_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "$ref": "#/definitions/content.configuration_model"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.configuration_update": {
            "type": "object",
            "properties": {
                "model": {
                    "$ref": "#/definitions/content.configuration_model",
                    "description": "The {@link ConfigurationModel} specifying the settings to update."
                }
            },
            "required": [
                "model"
            ]
        },
        "content.library.find_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.find_spec": {
            "type": "object",
            "properties": {
                "name": {
                    "description": "Name of the library to search. The name is case-insensitive. See {@link LibraryModel#name}.",
                    "type": "string"
                },
                "type": {
                    "description": "Library type to search. See {@link LibraryModel#type}.",
                    "$ref": "#/definitions/content.library_model.library_type"
                }
            }
        },
        "content.library.item.changes.info": {
            "type": "object",
            "properties": {
                "time": {
                    "description": "The date and time when the item content was changed.",
                    "type": "string",
                    "format": "date-time"
                },
                "user": {
                    "description": "The user who made the content change.",
                    "type": "string"
                },
                "message": {
                    "description": "The full message describing the content change.",
                    "type": "string"
                }
            },
            "required": [
                "time"
            ]
        },
        "content.library.item.changes.list_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/content.library.item.changes.summary"
                    }
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.changes.summary": {
            "type": "object",
            "properties": {
                "version": {
                    "description": "The version of the library item.",
                    "type": "string"
                },
                "time": {
                    "description": "The date and time when the item content was changed.",
                    "type": "string",
                    "format": "date-time"
                },
                "user": {
                    "description": "The user who made the content change.",
                    "type": "string"
                },
                "short_message": {
                    "description": "The short message describing the content change. The message is truncated to the first 80 characters or first non-leading newline character, whichever length is shorter.",
                    "type": "string"
                }
            },
            "required": [
                "version",
                "time"
            ]
        },
        "content.library.item.changes_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "$ref": "#/definitions/content.library.item.changes.info"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.copy_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "string"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.create_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "string"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.destination_spec": {
            "type": "object",
            "properties": {
                "subscription": {
                    "description": "Identifier of the subscription associated with the subscribed library.",
                    "type": "string"
                }
            },
            "required": [
                "subscription"
            ]
        },
        "content.library.item.download_session.create_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "string"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.download_session.list_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.download_session_create": {
            "type": "object",
            "properties": {
                "client_token": {
                    "type": "string",
                    "description": "A unique token generated by the client for each creation request. The token should be a universally unique identifier (UUID), for example: {@code b8a2a2e3-2314-43cd-a871-6ede0f429751}. This token can be used to guarantee idempotent creation."
                },
                "create_spec": {
                    "$ref": "#/definitions/content.library.item.download_session_model",
                    "description": "Specification for the new download session to be created."
                }
            },
            "required": [
                "create_spec"
            ]
        },
        "content.library.item.download_session_fail": {
            "type": "object",
            "properties": {
                "client_error_message": {
                    "type": "string",
                    "description": "Client side error message. This can be useful in providing some extra details about the client side failure. Note that the message won't be translated to the user's locale."
                }
            },
            "required": [
                "client_error_message"
            ]
        },
        "content.library.item.download_session_keep_alive": {
            "type": "object",
            "properties": {
                "progress": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Optional update to the progress property of the session. If specified, the new progress should be greater then the current progress. See {@link DownloadSessionModel#clientProgress}."
                }
            }
        },
        "content.library.item.download_session_model": {
            "type": "object",
            "properties": {
                "id": {
                    "description": "The identifier of this download session.",
                    "type": "string"
                },
                "library_item_id": {
                    "description": "The identifier of the library item whose content is being downloaded.",
                    "type": "string"
                },
                "library_item_content_version": {
                    "description": "The content version of the library item whose content is being downloaded. This value is the {@link ItemModel#contentVersion} at the time when the session is created for the library item.",
                    "type": "string"
                },
                "error_message": {
                    "description": "If the session is in the {@link State#ERROR} status this property will have more details about the error.",
                    "$ref": "#/definitions/vapi.std.localizable_message"
                },
                "client_progress": {
                    "description": "The progress that has been made with the download. This property is to be updated by the client during the download process to indicate the progress of its work in completing the download. The initial progress is 0 until updated by the client. The maximum value is 100, which indicates that the download is complete.",
                    "type": "integer",
                    "format": "int64"
                },
                "state": {
                    "description": "The current state ({@enum.values State}) of the download session.",
                    "$ref": "#/definitions/content.library.item.download_session_model.state"
                },
                "expiration_time": {
                    "description": "Indicates the time after which the session will expire. The session is guaranteed not to expire before this time.",
                    "type": "string",
                    "format": "date-time"
                }
            }
        },
        "content.library.item.download_session_model.state": {
            "type": "string",
            "description": "The state of the download session.",
            "enum": [
                "ACTIVE",
                "CANCELED",
                "ERROR"
            ]
        },
        "content.library.item.download_session_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "$ref": "#/definitions/content.library.item.download_session_model"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.downloadsession.file.endpoint_type": {
            "type": "string",
            "description": "The {@name EndpointType} {@term enumerated type} defines the types of endpoints used to download the file.",
            "enum": [
                "HTTPS",
                "DIRECT"
            ]
        },
        "content.library.item.downloadsession.file.info": {
            "type": "object",
            "properties": {
                "name": {
                    "description": "The name of the file.",
                    "type": "string"
                },
                "size": {
                    "description": "The file size, in bytes.",
                    "type": "integer",
                    "format": "int64"
                },
                "bytes_transferred": {
                    "description": "The number of bytes that have been transferred by the server so far for making this file prepared for download. This value may stay at zero till the client starts downloading the file.",
                    "type": "integer",
                    "format": "int64"
                },
                "status": {
                    "description": "The preparation status ({@enum.values PrepareStatus}) of the file.",
                    "$ref": "#/definitions/content.library.item.downloadsession.file.prepare_status"
                },
                "download_endpoint": {
                    "description": "Endpoint at which the file is available for download. The value is valid only when the {@link #status} is {@link File.PrepareStatus#PREPARED}.",
                    "$ref": "#/definitions/content.library.item.transfer_endpoint"
                },
                "checksum_info": {
                    "description": "The checksum information of the file. When the download is complete, you can retrieve the checksum from the {@link File#get} {@term operation} to verify the checksum for the downloaded file.",
                    "$ref": "#/definitions/content.library.item.file.checksum_info"
                },
                "error_message": {
                    "description": "Error message for a failed preparation when the prepare status is {@link File.PrepareStatus#ERROR}.",
                    "$ref": "#/definitions/vapi.std.localizable_message"
                }
            },
            "required": [
                "name",
                "bytes_transferred",
                "status"
            ]
        },
        "content.library.item.downloadsession.file.list_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/content.library.item.downloadsession.file.info"
                    }
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.downloadsession.file.prepare_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "$ref": "#/definitions/content.library.item.downloadsession.file.info"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.downloadsession.file.prepare_status": {
            "type": "string",
            "description": "The {@name PrepareStatus} {@term enumerated type} defines the state of the file in preparation for download.",
            "enum": [
                "UNPREPARED",
                "PREPARE_REQUESTED",
                "PREPARING",
                "PREPARED",
                "ERROR"
            ]
        },
        "content.library.item.downloadsession.file_get": {
            "type": "object",
            "properties": {
                "file_name": {
                    "type": "string",
                    "description": "Name of the file requested."
                }
            },
            "required": [
                "file_name"
            ]
        },
        "content.library.item.downloadsession.file_prepare": {
            "type": "object",
            "properties": {
                "file_name": {
                    "type": "string",
                    "description": "Name of the file requested for download."
                },
                "endpoint_type": {
                    "$ref": "#/definitions/content.library.item.downloadsession.file.endpoint_type",
                    "description": "Endpoint type request, one of {@enum.values EndpointType}. This will determine the type of the {@link File.Info#downloadEndpoint} that is generated when the file is prepared. The {@link EndpointType#DIRECT} is only available to users who have the ContentLibrary.ReadStorage privilege."
                }
            },
            "required": [
                "file_name"
            ]
        },
        "content.library.item.downloadsession.file_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "$ref": "#/definitions/content.library.item.downloadsession.file.info"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.file.checksum_algorithm": {
            "type": "string",
            "description": "The {@name ChecksumAlgorithm} {@term enumerated type} defines the valid checksum algorithms.",
            "enum": [
                "SHA1",
                "MD5",
                "SHA256",
                "SHA512"
            ]
        },
        "content.library.item.file.checksum_info": {
            "type": "object",
            "properties": {
                "algorithm": {
                    "description": "The checksum algorithm ({@enum.values ChecksumAlgorithm}) used to calculate the checksum.",
                    "$ref": "#/definitions/content.library.item.file.checksum_algorithm"
                },
                "checksum": {
                    "description": "The checksum value calculated with {@link #algorithm}.",
                    "type": "string"
                }
            },
            "required": [
                "checksum"
            ]
        },
        "content.library.item.file.info": {
            "type": "object",
            "properties": {
                "checksum_info": {
                    "description": "A checksum for validating the content of the file. <p> This value can be used to verify that a transfer was completed without errors.",
                    "$ref": "#/definitions/content.library.item.file.checksum_info"
                },
                "name": {
                    "description": "The name of the file. <p> This value will be unique within the library item for each file. It cannot be an empty string.",
                    "type": "string"
                },
                "size": {
                    "description": "The file size, in bytes. The file size is the storage used and not the uploaded or provisioned size. For example, when uploading a disk to a datastore, the amount of storage that the disk consumes may be different from the disk file size. When the file is not cached, the size is 0.",
                    "type": "integer",
                    "format": "int64"
                },
                "cached": {
                    "description": "Indicates whether the file is on disk or not.",
                    "type": "boolean"
                },
                "version": {
                    "description": "The version of this file; incremented when a new copy of the file is uploaded.",
                    "type": "string"
                }
            },
            "required": [
                "name",
                "size",
                "cached",
                "version"
            ]
        },
        "content.library.item.file.list_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/content.library.item.file.info"
                    }
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.file_get": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the file in the library item whose information should be returned."
                }
            },
            "required": [
                "name"
            ]
        },
        "content.library.item.file_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "$ref": "#/definitions/content.library.item.file.info"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.find_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.find_spec": {
            "type": "object",
            "properties": {
                "name": {
                    "description": "The name of the library item. The name is case-insensitive. See {@link ItemModel#name}.",
                    "type": "string"
                },
                "library_id": {
                    "description": "The identifier of the library containing the item. See {@link ItemModel#libraryId}.",
                    "type": "string"
                },
                "source_id": {
                    "description": "The identifier of the library item as reported by the publisher. See {@link ItemModel#sourceId}.",
                    "type": "string"
                },
                "type": {
                    "description": "The type of the library item. The type is case-insensitive. See {@link ItemModel#type}.",
                    "type": "string"
                },
                "cached": {
                    "description": "Whether the item is cached. Possible values are 'true' or 'false'. See {@link ItemModel#cached}.",
                    "type": "boolean"
                }
            }
        },
        "content.library.item.list_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.storage.info": {
            "type": "object",
            "properties": {
                "storage_backing": {
                    "description": "The storage backing on which this object resides. This might not be the same as the default storage backing associated with the library.",
                    "$ref": "#/definitions/content.library.storage_backing"
                },
                "storage_uris": {
                    "description": "URIs that identify the file on the storage backing. <p> These URIs may be specific to the backing and may need interpretation by the client. A client that understands a URI scheme in this list may use that URI to directly access the file on the storage backing. This can provide high-performance support for file manipulation.",
                    "type": "array",
                    "items": {
                        "type": "string",
                        "format": "uri"
                    }
                },
                "checksum_info": {
                    "description": "A checksum for validating the content of the file. <p> This value can be used to verify that a transfer was completed without errors.",
                    "$ref": "#/definitions/content.library.item.file.checksum_info"
                },
                "name": {
                    "description": "The name of the file. <p> This value will be unique within the library item for each file. It cannot be an empty string.",
                    "type": "string"
                },
                "size": {
                    "description": "The file size, in bytes. The file size is the storage used and not the uploaded or provisioned size. For example, when uploading a disk to a datastore, the amount of storage that the disk consumes may be different from the disk file size. When the file is not cached, the size is 0.",
                    "type": "integer",
                    "format": "int64"
                },
                "cached": {
                    "description": "Indicates whether the file is on disk or not.",
                    "type": "boolean"
                },
                "version": {
                    "description": "The version of this file; incremented when a new copy of the file is uploaded.",
                    "type": "string"
                }
            },
            "required": [
                "storage_backing",
                "storage_uris",
                "name",
                "size",
                "cached",
                "version"
            ]
        },
        "content.library.item.storage.list_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/content.library.item.storage.info"
                    }
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.storage_get": {
            "type": "object",
            "properties": {
                "file_name": {
                    "type": "string",
                    "description": "Name of the file for which the storage information should be listed."
                }
            },
            "required": [
                "file_name"
            ]
        },
        "content.library.item.storage_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/content.library.item.storage.info"
                    }
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.transfer_endpoint": {
            "type": "object",
            "properties": {
                "uri": {
                    "description": "Transfer endpoint URI. The supported URI schemes are: {@code http}, {@code https}, and {@code ds}. <p> An endpoint URI with the {@code ds} scheme specifies the location of the file on the datastore. The format of the datastore URI is: <ul> <li>ds:///vmfs/volumes/uuid/path</li> </ul> <p> When the transfer endpoint is a datastore location, the server can import the file directly from the storage backing without the overhead of streaming over HTTP.",
                    "type": "string",
                    "format": "uri"
                },
                "ssl_certificate_thumbprint": {
                    "description": "Thumbprint of the expected SSL certificate for this endpoint. Only used for HTTPS connections. The thumbprint is the SHA-1 hash of the DER encoding of the remote endpoint's SSL certificate. If set, the remote endpoint's SSL certificate is only accepted if it matches this thumbprint, and no other certificate validation is performed.",
                    "type": "string"
                }
            },
            "required": [
                "uri"
            ]
        },
        "content.library.item.transfer_status": {
            "type": "string",
            "description": "The {@name TransferStatus} {@term enumerated type} defines the transfer state of a file.",
            "enum": [
                "WAITING_FOR_TRANSFER",
                "TRANSFERRING",
                "READY",
                "VALIDATING",
                "ERROR"
            ]
        },
        "content.library.item.update_session.create_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "string"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.update_session.list_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.update_session_create": {
            "type": "object",
            "properties": {
                "client_token": {
                    "type": "string",
                    "description": "Unique token generated by the client for each creation request. The token should be a universally unique identifier (UUID), for example: {@code b8a2a2e3-2314-43cd-a871-6ede0f429751}. This token can be used to guarantee idempotent creation."
                },
                "create_spec": {
                    "$ref": "#/definitions/content.library.item.update_session_model",
                    "description": "Specification for the new update session to be created."
                }
            },
            "required": [
                "create_spec"
            ]
        },
        "content.library.item.update_session_fail": {
            "type": "object",
            "properties": {
                "client_error_message": {
                    "type": "string",
                    "description": "Client side error message. This can be useful in providing some extra details about the client side failure. Note that the message won't be translated to the user's locale."
                }
            },
            "required": [
                "client_error_message"
            ]
        },
        "content.library.item.update_session_keep_alive": {
            "type": "object",
            "properties": {
                "client_progress": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Optional update to the progress property of the session. If specified, the new progress should be greater then the current progress. See {@link UpdateSessionModel#clientProgress}."
                }
            }
        },
        "content.library.item.update_session_model": {
            "type": "object",
            "properties": {
                "id": {
                    "description": "The identifier of this update session.",
                    "type": "string"
                },
                "library_item_id": {
                    "description": "The identifier of the library item to which content will be uploaded or removed.",
                    "type": "string"
                },
                "library_item_content_version": {
                    "description": "The content version of the library item whose content is being modified. This value is the {@link ItemModel#contentVersion} at the time when the session is created for the library item.",
                    "type": "string"
                },
                "error_message": {
                    "description": "If the session is in the {@link State#ERROR} status this property will have more details about the error.",
                    "$ref": "#/definitions/vapi.std.localizable_message"
                },
                "client_progress": {
                    "description": "The progress that has been made with the upload. This property is to be updated by the client during the upload process to indicate the progress of its work in completing the upload. The initial progress is 0 until updated by the client. The maximum value is 100, which indicates that the update is complete.",
                    "type": "integer",
                    "format": "int64"
                },
                "state": {
                    "description": "The current state ({@enum.values State}) of the update session.",
                    "$ref": "#/definitions/content.library.item.update_session_model.state"
                },
                "expiration_time": {
                    "description": "Indicates the time after which the session will expire. The session is guaranteed not to expire earlier than this time.",
                    "type": "string",
                    "format": "date-time"
                },
                "preview_info": {
                    "description": "A preview of the files currently being uploaded in the session. This property will be set only when the session is in the {@link State#ACTIVE}.",
                    "$ref": "#/definitions/content.library.item.updatesession.preview_info"
                },
                "warning_behavior": {
                    "description": "Indicates the update session behavior if warnings are raised in the session preview. Any warning which is raised by session preview but not ignored by the client will, by default, fail the update session.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/content.library.item.updatesession.warning_behavior"
                    }
                }
            }
        },
        "content.library.item.update_session_model.state": {
            "type": "string",
            "description": "The state of an update session.",
            "enum": [
                "ACTIVE",
                "DONE",
                "ERROR",
                "CANCELED"
            ]
        },
        "content.library.item.update_session_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "$ref": "#/definitions/content.library.item.update_session_model"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.update_session_update": {
            "type": "object",
            "properties": {
                "update_spec": {
                    "$ref": "#/definitions/content.library.item.update_session_model",
                    "description": "Specification for the new property values to be set on the update session."
                }
            },
            "required": [
                "update_spec"
            ]
        },
        "content.library.item.updatesession.certificate_info": {
            "type": "object",
            "properties": {
                "issuer": {
                    "description": "Certificate issuer. For example: /C=US/ST=California/L=Palo Alto/O=VMware, Inc.",
                    "type": "string"
                },
                "subject": {
                    "description": "Certificate subject. For example: C=US/ST=Massachusetts/L=Hopkinton/O=EMC Corporation/OU=EMC Avamar/CN=EMC Corporation.",
                    "type": "string"
                },
                "self_signed": {
                    "description": "Whether the certificate is self-signed.",
                    "type": "boolean"
                },
                "x509": {
                    "description": "The X509 representation of the certificate.",
                    "type": "string"
                }
            },
            "required": [
                "issuer",
                "subject",
                "self_signed",
                "x509"
            ]
        },
        "content.library.item.updatesession.file.add_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "$ref": "#/definitions/content.library.item.updatesession.file.info"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.updatesession.file.add_spec": {
            "type": "object",
            "properties": {
                "name": {
                    "description": "The name of the file being uploaded.",
                    "type": "string"
                },
                "source_type": {
                    "description": "The source type ({@enum.values SourceType}) from which the file content will be retrieved.",
                    "$ref": "#/definitions/content.library.item.updatesession.file.source_type"
                },
                "source_endpoint": {
                    "description": "Location from which the Content Library Service will fetch the file, rather than requiring a client to upload the file.",
                    "$ref": "#/definitions/content.library.item.transfer_endpoint"
                },
                "size": {
                    "description": "The file size, in bytes.",
                    "type": "integer",
                    "format": "int64"
                },
                "checksum_info": {
                    "description": "The checksum of the file. If specified, the server will verify the checksum once the file is received. If there is a mismatch, the upload will fail. For ova files, this value should not be set.",
                    "$ref": "#/definitions/content.library.item.file.checksum_info"
                }
            },
            "required": [
                "name",
                "source_type"
            ]
        },
        "content.library.item.updatesession.file.info": {
            "type": "object",
            "properties": {
                "name": {
                    "description": "The name of the file.",
                    "type": "string"
                },
                "source_type": {
                    "description": "The source type ({@enum.values SourceType}) from which the file is being retrieved. This may be {@link SourceType#NONE} if the file is not being changed.",
                    "$ref": "#/definitions/content.library.item.updatesession.file.source_type"
                },
                "size": {
                    "description": "The file size, in bytes as received by the server. This {@term field} is guaranteed to be set when the server has completely received the file.",
                    "type": "integer",
                    "format": "int64"
                },
                "checksum_info": {
                    "description": "The checksum information of the file received by the server.",
                    "$ref": "#/definitions/content.library.item.file.checksum_info"
                },
                "source_endpoint": {
                    "description": "A source endpoint from which to retrieve the file.",
                    "$ref": "#/definitions/content.library.item.transfer_endpoint"
                },
                "upload_endpoint": {
                    "description": "An upload endpoint to which the client can push the content.",
                    "$ref": "#/definitions/content.library.item.transfer_endpoint"
                },
                "bytes_transferred": {
                    "description": "The number of bytes of this file that have been received by the server.",
                    "type": "integer",
                    "format": "int64"
                },
                "status": {
                    "description": "The transfer status ({@enum.values TransferStatus}) of this file.",
                    "$ref": "#/definitions/content.library.item.transfer_status"
                },
                "error_message": {
                    "description": "Details about the transfer error.",
                    "$ref": "#/definitions/vapi.std.localizable_message"
                },
                "keep_in_storage": {
                    "description": "Whether or not the file will be kept in storage upon update session completion. The flag is true for most files, and false for metadata files such as manifest and certificate file of update session with library item type OVF. Any file with {@link Info#keepInStorage} set to false will not show up in the list of files returned from {@link content.library.item.File#list} upon update session completion.",
                    "type": "boolean"
                }
            },
            "required": [
                "name",
                "source_type",
                "bytes_transferred",
                "status"
            ]
        },
        "content.library.item.updatesession.file.list_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/content.library.item.updatesession.file.info"
                    }
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.updatesession.file.source_type": {
            "type": "string",
            "description": "The {@name SourceType} {@term enumerated type} defines how the file content is retrieved.",
            "enum": [
                "NONE",
                "PUSH",
                "PULL"
            ]
        },
        "content.library.item.updatesession.file.validate_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "$ref": "#/definitions/content.library.item.updatesession.file.validation_result"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.updatesession.file.validation_error": {
            "type": "object",
            "properties": {
                "name": {
                    "description": "The name of the file.",
                    "type": "string"
                },
                "error_message": {
                    "description": "A message indicating why the file was considered invalid.",
                    "$ref": "#/definitions/vapi.std.localizable_message"
                }
            },
            "required": [
                "name",
                "error_message"
            ]
        },
        "content.library.item.updatesession.file.validation_result": {
            "type": "object",
            "properties": {
                "has_errors": {
                    "description": "Whether the validation was succesful or not. In case of errors, the {@link #missingFiles} and {@link #invalidFiles} will contain at least one entry.",
                    "type": "boolean"
                },
                "missing_files": {
                    "description": "A {@term set} containing the names of the files that are required but the client hasn't added.",
                    "type": "array",
                    "uniqueItems": true,
                    "items": {
                        "type": "string"
                    }
                },
                "invalid_files": {
                    "description": "A {@term list} containing the files that have been identified as invalid and details about the error.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/content.library.item.updatesession.file.validation_error"
                    }
                }
            },
            "required": [
                "has_errors",
                "missing_files",
                "invalid_files"
            ]
        },
        "content.library.item.updatesession.file_add": {
            "type": "object",
            "properties": {
                "file_spec": {
                    "$ref": "#/definitions/content.library.item.updatesession.file.add_spec",
                    "description": "Specification for the file that needs to be added or updated. This includes whether the client wants to push the content or have the server pull it."
                }
            },
            "required": [
                "file_spec"
            ]
        },
        "content.library.item.updatesession.file_get": {
            "type": "object",
            "properties": {
                "file_name": {
                    "type": "string",
                    "description": "Name of the file."
                }
            },
            "required": [
                "file_name"
            ]
        },
        "content.library.item.updatesession.file_remove": {
            "type": "object",
            "properties": {
                "file_name": {
                    "type": "string",
                    "description": "Name of the file to be removed."
                }
            },
            "required": [
                "file_name"
            ]
        },
        "content.library.item.updatesession.file_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "$ref": "#/definitions/content.library.item.updatesession.file.info"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item.updatesession.preview_info": {
            "type": "object",
            "properties": {
                "state": {
                    "description": "Indicates the state of the preview of the update session.",
                    "$ref": "#/definitions/content.library.item.updatesession.preview_info.state"
                },
                "certificate_info": {
                    "description": "The certificate information of the signed update session content.",
                    "$ref": "#/definitions/content.library.item.updatesession.certificate_info"
                },
                "warnings": {
                    "description": "The list of warnings raised for this update session. Any warning which is not ignored by the client will, by default, fail the update session during session complete operation.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/content.library.item.updatesession.preview_warning_info"
                    }
                }
            },
            "required": [
                "state"
            ]
        },
        "content.library.item.updatesession.preview_info.state": {
            "type": "string",
            "description": "The {@name State} {@term enumerated type} defines the state of the update session's preview.",
            "enum": [
                "UNAVAILABLE",
                "NOT_APPLICABLE",
                "PREPARING",
                "AVAILABLE"
            ]
        },
        "content.library.item.updatesession.preview_warning_info": {
            "type": "object",
            "properties": {
                "type": {
                    "description": "The warning type raised during preview of the update session.",
                    "$ref": "#/definitions/content.library.item.updatesession.warning_type"
                },
                "message": {
                    "description": "The message specifying more details about the warning.",
                    "$ref": "#/definitions/vapi.std.localizable_message"
                },
                "ignored": {
                    "description": "Indicates if this warning will be ignored during session complete operation.",
                    "type": "boolean"
                }
            },
            "required": [
                "type",
                "message",
                "ignored"
            ]
        },
        "content.library.item.updatesession.warning_behavior": {
            "type": "object",
            "properties": {
                "type": {
                    "description": "The warning type which may be raised during the update session.",
                    "$ref": "#/definitions/content.library.item.updatesession.warning_type"
                },
                "ignored": {
                    "description": "Indicates if this warning will be ignored during session complete operation.",
                    "type": "boolean"
                }
            },
            "required": [
                "type",
                "ignored"
            ]
        },
        "content.library.item.updatesession.warning_type": {
            "type": "string",
            "description": "The {@name WarningType} {@term enumerated type} defines the warnings which can be raised during the update session.",
            "enum": [
                "SELF_SIGNED_CERTIFICATE",
                "EXPIRED_CERTIFICATE",
                "NOT_YET_VALID_CERTIFICATE",
                "UNTRUSTED_CERTIFICATE"
            ]
        },
        "content.library.item_copy": {
            "type": "object",
            "properties": {
                "client_token": {
                    "type": "string",
                    "description": "A unique token generated on the client for each copy request. The token should be a universally unique identifier (UUID), for example: {@code b8a2a2e3-2314-43cd-a871-6ede0f429751}. This token can be used to guarantee idempotent copy."
                },
                "destination_create_spec": {
                    "$ref": "#/definitions/content.library.item_model",
                    "description": "Specification for the new library item to be created."
                }
            },
            "required": [
                "destination_create_spec"
            ]
        },
        "content.library.item_create": {
            "type": "object",
            "properties": {
                "client_token": {
                    "type": "string",
                    "description": "A unique token generated on the client for each creation request. The token should be a universally unique identifier (UUID), for example: {@code b8a2a2e3-2314-43cd-a871-6ede0f429751}. This token can be used to guarantee idempotent creation."
                },
                "create_spec": {
                    "$ref": "#/definitions/content.library.item_model",
                    "description": "Specification that defines the properties of the new library item."
                }
            },
            "required": [
                "create_spec"
            ]
        },
        "content.library.item_find": {
            "type": "object",
            "properties": {
                "spec": {
                    "$ref": "#/definitions/content.library.item.find_spec",
                    "description": "Specification describing what properties to filter on."
                }
            },
            "required": [
                "spec"
            ]
        },
        "content.library.item_model": {
            "type": "object",
            "properties": {
                "id": {
                    "description": "A unique identifier for this library item.",
                    "type": "string"
                },
                "library_id": {
                    "description": "The identifier of the {@link LibraryModel} to which this item belongs.",
                    "type": "string"
                },
                "content_version": {
                    "description": "The latest version of the file content list of this library item.",
                    "type": "string"
                },
                "creation_time": {
                    "description": "The date and time when this library item was created.",
                    "type": "string",
                    "format": "date-time"
                },
                "description": {
                    "description": "A human-readable description for this library item.",
                    "type": "string"
                },
                "last_modified_time": {
                    "description": "The date and time when the metadata for this library item was last changed. <p> This {@term field} is affected by changes to the properties or file content of this item. It is not modified by changes to the tags of the item, or by changes to the library which owns this item.",
                    "type": "string",
                    "format": "date-time"
                },
                "last_sync_time": {
                    "description": "The date and time when this library item was last synchronized. <p> This {@term field} is updated every time a synchronization is triggered on the library item, including when a synchronization is triggered on the library to which this item belongs. The value is {@term unset} for a library item that belongs to a local library.",
                    "type": "string",
                    "format": "date-time"
                },
                "metadata_version": {
                    "description": "A version number for the metadata of this library item. <p> This value is incremented with each change to the metadata of this item. Changes to name, description, and so on will increment this value. The value is not incremented by changes to the content or tags of the item or the library which owns it.",
                    "type": "string"
                },
                "name": {
                    "description": "A human-readable name for this library item. <p> The name may not be {@term unset} or an empty string. The name does not have to be unique, even within the same library.",
                    "type": "string"
                },
                "cached": {
                    "description": "The status that indicates whether the library item is on disk or not. The library item is cached when all its files are on disk.",
                    "type": "boolean"
                },
                "size": {
                    "description": "The library item size, in bytes. The size is the sum of the size used on the storage backing for all the files in the item. When the library item is not cached, the size is 0.",
                    "type": "integer",
                    "format": "int64"
                },
                "type": {
                    "description": "An optional type identifier which indicates the type adapter plugin to use. <p> This {@term field} may be set to a non-empty string value that corresponds to an identifier supported by a type adapter plugin present in the Content Library Service. A type adapter plugin, if present for the specified type, can provide additional information and services around the item content. A type adapter can guide the upload process by creating file entries that are in need of being uploaded to complete an item. <p> The types and plugins supported by the Content Library Service can be queried using the {@link Type} {@term service}.",
                    "type": "string"
                },
                "version": {
                    "description": "A version number that is updated on metadata changes. This value is used to validate update requests to provide optimistic concurrency of changes. <p> This value represents a number that is incremented every time library item properties, such as name or description, are changed. It is not incremented by changes to the file content of the library item, including adding or removing files. It is also not affected by tagging the library item.",
                    "type": "string"
                },
                "source_id": {
                    "description": "The identifier of the {@link ItemModel} to which this item is synchronized to if the item belongs to a subscribed library. The value is {@term unset} for a library item that belongs to a local library.",
                    "type": "string"
                }
            }
        },
        "content.library.item_publish": {
            "type": "object",
            "properties": {
                "force_sync_content": {
                    "type": "boolean",
                    "description": "Whether to synchronize file content as well as metadata. This {@term parameter} applies only if the subscription is on-demand."
                },
                "subscriptions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/content.library.item.destination_spec"
                    },
                    "description": "The list of subscriptions to publish this library item to."
                }
            },
            "required": [
                "force_sync_content"
            ]
        },
        "content.library.item_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "$ref": "#/definitions/content.library.item_model"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.item_update": {
            "type": "object",
            "properties": {
                "update_spec": {
                    "$ref": "#/definitions/content.library.item_model",
                    "description": "Specification of the properties to set."
                }
            },
            "required": [
                "update_spec"
            ]
        },
        "content.library.list_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.optimization_info": {
            "type": "object",
            "properties": {
                "optimize_remote_publishing": {
                    "description": "If set to {@code true} then library would be optimized for remote publishing. <p> Turn it on if remote publishing is dominant use case for this library. Remote publishing means here that publisher and subscribers are not the part of the same {@name Vcenter} SSO domain. <p> Any optimizations could be done as result of turning on this optimization during library creation. For example, library content could be stored in different format but optimizations are not limited to just storage format. <p> Note, that value of this toggle could be set only during creation of the library and you would need to migrate your library in case you need to change this value (optimize the library for different use case).",
                    "type": "boolean"
                }
            }
        },
        "content.library.publish_info": {
            "type": "object",
            "properties": {
                "authentication_method": {
                    "description": "Indicates how a subscribed library should authenticate ({@enum.values AuthenticationMethod}) to the published library endpoint.",
                    "$ref": "#/definitions/content.library.publish_info.authentication_method"
                },
                "published": {
                    "description": "Whether the local library is published.",
                    "type": "boolean"
                },
                "publish_url": {
                    "description": "The URL to which the library metadata is published by the Content Library Service. <p> This value can be used to set the {@link SubscriptionInfo#subscriptionUrl} property when creating a subscribed library.",
                    "type": "string",
                    "format": "uri"
                },
                "user_name": {
                    "description": "The username to require for authentication.",
                    "type": "string"
                },
                "password": {
                    "description": "The new password to require for authentication.",
                    "type": "string",
                    "format": "password"
                },
                "current_password": {
                    "description": "The current password to verify. This {@term field} is available starting in vSphere 6.7.",
                    "type": "string",
                    "format": "password"
                },
                "persist_json_enabled": {
                    "description": "Whether library and library item metadata are persisted in the storage backing as JSON files. This flag only applies if the local library is published. <p> Enabling JSON persistence allows you to synchronize a subscribed library manually instead of over HTTP. You copy the local library content and metadata to another storage backing manually and then create a subscribed library referencing the location of the library JSON file in the {@link SubscriptionInfo#subscriptionUrl}. When the subscribed library's storage backing matches the subscription URL, files do not need to be copied to the subscribed library. <p> For a library backed by a datastore, the library JSON file will be stored at the path contentlib-{library_id}/lib.json on the datastore. <p> For a library backed by a remote file system, the library JSON file will be stored at {library_id}/lib.json in the remote file system path.",
                    "type": "boolean"
                }
            }
        },
        "content.library.publish_info.authentication_method": {
            "type": "string",
            "description": "The {@name AuthenticationMethod} {@term enumerated type} indicates how a subscribed library should authenticate to the published library endpoint.",
            "enum": [
                "BASIC",
                "NONE"
            ]
        },
        "content.library.source_info": {
            "type": "object",
            "properties": {
                "source_library": {
                    "description": "Identifier of the published library.",
                    "type": "string"
                },
                "subscription": {
                    "description": "Identifier of the subscription associated with the subscribed library.",
                    "type": "string"
                }
            }
        },
        "content.library.storage_backing": {
            "type": "object",
            "properties": {
                "type": {
                    "description": "Type ({@enum.values Type}) of {@link StorageBacking}.",
                    "$ref": "#/definitions/content.library.storage_backing.type"
                },
                "datastore_id": {
                    "description": "Identifier of the datastore used to store the content in the library.",
                    "type": "string"
                },
                "storage_uri": {
                    "description": "URI identifying the location used to store the content in the library. <p> The following URI formats are supported: <p> vSphere 6.5 <ul> <li>nfs://server/path?version=4 (for vCenter Server Appliance only) - Specifies an NFS Version 4 server.</li> <li>nfs://server/path (for vCenter Server Appliance only) - Specifies an NFS Version 3 server. The nfs://server:/path format is also supported.</li> <li>smb://server/path - Specifies an SMB server or Windows share.</li> </ul> <p> vSphere 6.0 Update 1 <ul> <li>nfs://server:/path (for vCenter Server Appliance only)</li> <li>file://unc-server/path (for vCenter Server for Windows only)</li> <li>file:///mount/point (for vCenter Server Appliance only) - Local file URIs are supported only when the path is a local mount point for an NFS file system. Use of file URIs is strongly discouraged. Instead, use an NFS URI to specify the remote file system.</li> </ul> <p> vSphere 6.0 <ul> <li>nfs://server:/path (for vCenter Server Appliance only)</li> <li>file://unc-server/path (for vCenter Server for Windows only)</li> <li>file:///path - Local file URIs are supported but strongly discouraged because it may interfere with the performance of vCenter Server.</li> </ul>",
                    "type": "string",
                    "format": "uri"
                }
            }
        },
        "content.library.storage_backing.type": {
            "type": "string",
            "description": "The {@name Type} {@term enumerated type} specifies the type of the {@link StorageBacking}.",
            "enum": [
                "DATASTORE",
                "OTHER"
            ]
        },
        "content.library.subscribed_item_sync": {
            "type": "object",
            "properties": {
                "force_sync_content": {
                    "type": "boolean",
                    "description": "Whether to synchronize file content as well as metadata. This {@term parameter} applies only if the subscription is on-demand."
                }
            },
            "required": [
                "force_sync_content"
            ]
        },
        "content.library.subscription_info": {
            "type": "object",
            "properties": {
                "authentication_method": {
                    "description": "Indicate how the subscribed library should authenticate ({@enum.values AuthenticationMethod}) with the published library endpoint.",
                    "$ref": "#/definitions/content.library.subscription_info.authentication_method"
                },
                "automatic_sync_enabled": {
                    "description": "Whether the library should participate in automatic library synchronization. In order for automatic synchronization to happen, the global {@link ConfigurationModel#automaticSyncEnabled} option must also be true. The subscription is still active even when automatic synchronization is turned off, but synchronization is only activated with an explicit call to {@link SubscribedLibrary#sync} or {@link SubscribedItem#sync}. In other words, manual synchronization is still available even when automatic synchronization is disabled.",
                    "type": "boolean"
                },
                "on_demand": {
                    "description": "Indicates whether a library item's content will be synchronized only on demand. <p> If this is set to {@code true}, then the library item's metadata will be synchronized but the item's content (its files) will not be synchronized. The Content Library Service will synchronize the content upon request only. This can cause the first use of the content to have a noticeable delay. <p> Items without synchronized content can be forcefully synchronized in advance using the {@link SubscribedItem#sync} call with {@param.name forceSyncContent} set to true. Once content has been synchronized, the content can removed with the {@link SubscribedItem#evict} call. <p> If this value is set to {@code false}, all content will be synchronized in advance.",
                    "type": "boolean"
                },
                "password": {
                    "description": "The password to use when authenticating. <p> The password must be set when using a password-based authentication method; empty strings are not allowed.",
                    "type": "string",
                    "format": "password"
                },
                "ssl_thumbprint": {
                    "description": "An optional SHA-1 hash of the SSL certificate for the remote endpoint. <p> If this value is defined the SSL certificate will be verified by comparing it to the SSL thumbprint. The SSL certificate must verify against the thumbprint. When specified, the standard certificate chain validation behavior is not used. The certificate chain is validated normally if this value is {@term unset}.",
                    "type": "string"
                },
                "subscription_url": {
                    "description": "The URL of the endpoint where the metadata for the remotely published library is being served. <p> This URL can be the {@link PublishInfo#publishUrl} of the published library (for example, https://server/path/lib.json). <p> If the source content comes from a published library with {@link PublishInfo#persistJsonEnabled}, the subscription URL can be a URL pointing to the library JSON file on a datastore or remote file system. The supported formats are: <p> vSphere 6.5 <ul> <li>ds:///vmfs/volumes/{uuid}/mylibrary/lib.json (for datastore)</li> <li>nfs://server/path/mylibrary/lib.json (for NFSv3 server on vCenter Server Appliance)</li> <li>nfs://server/path/mylibrary/lib.json?version=4 (for NFSv4 server on vCenter Server Appliance) </li> <li>smb://server/path/mylibrary/lib.json (for SMB server)</li> </ul> <p> vSphere 6.0 <ul> <li>file://server/mylibrary/lib.json (for UNC server on vCenter Server for Windows)</li> <li>file:///path/mylibrary/lib.json (for local file system)</li> </ul> <p> When you specify a DS subscription URL, the datastore must be on the same vCenter Server as the subscribed library. When you specify an NFS or SMB subscription URL, the {@link StorageBacking#storageUri} of the subscribed library must be on the same remote file server and should share a common parent path with the subscription URL.",
                    "type": "string",
                    "format": "uri"
                },
                "user_name": {
                    "description": "The username to use when authenticating. <p> The username must be set when using a password-based authentication method. Empty strings are allowed for usernames.",
                    "type": "string"
                },
                "source_info": {
                    "description": "Information about the source published library. This {@term field} will be set for a subscribed library which is associated with a subscription of the published library.",
                    "$ref": "#/definitions/content.library.source_info"
                }
            }
        },
        "content.library.subscription_info.authentication_method": {
            "type": "string",
            "description": "Indicate how the subscribed library should authenticate with the published library endpoint.",
            "enum": [
                "BASIC",
                "NONE"
            ]
        },
        "content.library.subscriptions.create_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "string"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.subscriptions.create_spec": {
            "type": "object",
            "properties": {
                "subscribed_library": {
                    "description": "Specification for the subscribed library to be associated with the subscription.",
                    "$ref": "#/definitions/content.library.subscriptions.create_spec_subscribed_library"
                }
            },
            "required": [
                "subscribed_library"
            ]
        },
        "content.library.subscriptions.create_spec_new_subscribed_library": {
            "type": "object",
            "properties": {
                "name": {
                    "description": "Name of the subscribed library.",
                    "type": "string"
                },
                "description": {
                    "description": "Description of the subscribed library.",
                    "type": "string"
                },
                "storage_backings": {
                    "description": "The list of default storage backings for this library. <p> The list must contain exactly one storage backing. Multiple default storage locations are not currently supported but may become supported in future releases.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/content.library.storage_backing"
                    }
                },
                "automatic_sync_enabled": {
                    "description": "Specifies whether the library should participate in automatic library synchronization.",
                    "type": "boolean"
                },
                "on_demand": {
                    "description": "Specifies whether a library item's content will be synchronized only on demand.",
                    "type": "boolean"
                }
            },
            "required": [
                "name",
                "storage_backings",
                "automatic_sync_enabled",
                "on_demand"
            ]
        },
        "content.library.subscriptions.create_spec_placement": {
            "type": "object",
            "properties": {
                "folder": {
                    "description": "Virtual machine folder into which the virtual machine template should be placed.",
                    "type": "string"
                },
                "cluster": {
                    "description": "Cluster onto which the virtual machine template should be placed. If {@name #cluster} and {@name #resourcePool} are both specified, {@name #resourcePool} must belong to {@name #cluster}. If {@name #cluster} and {@name #host} are both specified, {@name #host} must be a member of {@name #cluster}.",
                    "type": "string"
                },
                "resource_pool": {
                    "description": "Resource pool into which the virtual machine template should be placed. If {@name #host} and {@name #resourcePool} are both specified, {@name #resourcePool} must belong to {@name #host}. If {@name #cluster} and {@name #resourcePool} are both specified, {@name #resourcePool} must belong to {@name #cluster}.",
                    "type": "string"
                },
                "host": {
                    "description": "Host onto which the virtual machine template should be placed. If {@name #host} and {@name #resourcePool} are both specified, {@name #resourcePool} must belong to {@name #host}. If {@name #host} and {@name #cluster} are both specified, {@name #host} must be a member of {@name #cluster}.",
                    "type": "string"
                },
                "network": {
                    "description": "Network that backs the virtual Ethernet adapters in the virtual machine template.",
                    "type": "string"
                }
            }
        },
        "content.library.subscriptions.create_spec_subscribed_library": {
            "type": "object",
            "properties": {
                "target": {
                    "description": "Specifies whether the target subscribed library should be newly created or an existing subscribed library should be used.",
                    "$ref": "#/definitions/content.library.subscriptions.create_spec_subscribed_library.target"
                },
                "new_subscribed_library": {
                    "description": "Specification for creating a new subscribed library associated with the subscription.",
                    "$ref": "#/definitions/content.library.subscriptions.create_spec_new_subscribed_library"
                },
                "subscribed_library": {
                    "description": "Identifier of the existing subscribed library to associate with the subscription. Only the subscribed libraries for which {@link SubscriptionInfo#subscriptionUrl} property is set to the {@link PublishInfo#publishUrl} of the published library can be associated with the subscription.",
                    "type": "string"
                },
                "location": {
                    "description": "Location of the subscribed library relative to the published library.",
                    "$ref": "#/definitions/content.library.subscriptions.location"
                },
                "vcenter": {
                    "description": "Specification for the subscribed library's vCenter Server instance.",
                    "$ref": "#/definitions/content.library.subscriptions.create_spec_vcenter"
                },
                "placement": {
                    "description": "Placement specification for the virtual machine template library items on the subscribed library.",
                    "$ref": "#/definitions/content.library.subscriptions.create_spec_placement"
                }
            },
            "required": [
                "target",
                "location"
            ]
        },
        "content.library.subscriptions.create_spec_subscribed_library.target": {
            "type": "string",
            "description": "The {@name Target} {@term enumerated type} defines the options related to the target subscribed library which will be associated with the subscription.",
            "enum": [
                "CREATE_NEW",
                "USE_EXISTING"
            ]
        },
        "content.library.subscriptions.create_spec_vcenter": {
            "type": "object",
            "properties": {
                "hostname": {
                    "description": "The hostname of the subscribed library's vCenter Server.",
                    "type": "string"
                },
                "https_port": {
                    "description": "The HTTPS port of the vCenter Server instance where the subscribed library exists.",
                    "type": "integer",
                    "format": "int64"
                }
            },
            "required": [
                "hostname"
            ]
        },
        "content.library.subscriptions.info": {
            "type": "object",
            "properties": {
                "subscribed_library": {
                    "description": "Identifier of the subscribed library associated with the subscription.",
                    "type": "string"
                },
                "subscribed_library_name": {
                    "description": "Name of the subscribed library associated with the subscription.",
                    "type": "string"
                },
                "subscribed_library_location": {
                    "description": "Location of the subscribed library relative to the published library.",
                    "$ref": "#/definitions/content.library.subscriptions.location"
                },
                "subscribed_library_vcenter": {
                    "description": "Information about the vCenter Server instance where the subscribed library exists.",
                    "$ref": "#/definitions/content.library.subscriptions.vcenter_info"
                },
                "subscribed_library_placement": {
                    "description": "Placement information about the subscribed library's virtual machine template items.",
                    "$ref": "#/definitions/content.library.subscriptions.placement_info"
                }
            },
            "required": [
                "subscribed_library",
                "subscribed_library_name",
                "subscribed_library_location",
                "subscribed_library_placement"
            ]
        },
        "content.library.subscriptions.list_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/content.library.subscriptions.summary"
                    }
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.subscriptions.location": {
            "type": "string",
            "description": "The {@name Location} {@term enumerated type} defines the location of subscribed library relative to the published library.",
            "enum": [
                "LOCAL",
                "REMOTE"
            ]
        },
        "content.library.subscriptions.placement_info": {
            "type": "object",
            "properties": {
                "folder": {
                    "description": "Virtual machine folder into which the virtual machine template should be placed.",
                    "type": "string"
                },
                "cluster": {
                    "description": "Cluster onto which the virtual machine template should be placed.",
                    "type": "string"
                },
                "resource_pool": {
                    "description": "Resource pool into which the virtual machine template should be placed.",
                    "type": "string"
                },
                "host": {
                    "description": "Host onto which the virtual machine template should be placed. If {@name #host} and {@name #resourcePool} are both specified, {@name #resourcePool} must belong to {@name #host}. If {@name #host} and {@name #cluster} are both specified, {@name #host} must be a member of {@name #cluster}.",
                    "type": "string"
                },
                "network": {
                    "description": "Network that backs the virtual Ethernet adapters in the virtual machine template.",
                    "type": "string"
                }
            }
        },
        "content.library.subscriptions.summary": {
            "type": "object",
            "properties": {
                "subscription": {
                    "description": "Identifier of the subscription.",
                    "type": "string"
                },
                "subscribed_library": {
                    "description": "Identifier of the subscribed library.",
                    "type": "string"
                },
                "subscribed_library_name": {
                    "description": "Name of the subscribed library.",
                    "type": "string"
                },
                "subscribed_library_vcenter_hostname": {
                    "description": "Hostname of the vCenter instance where the subscribed library exists.",
                    "type": "string"
                }
            },
            "required": [
                "subscription",
                "subscribed_library",
                "subscribed_library_name"
            ]
        },
        "content.library.subscriptions.update_spec": {
            "type": "object",
            "properties": {
                "subscribed_library_vcenter": {
                    "description": "Specification for the subscribed library's vCenter Server instance.",
                    "$ref": "#/definitions/content.library.subscriptions.update_spec_vcenter"
                },
                "subscribed_library_placement": {
                    "description": "Placement specification for the virtual machine template items of the subscribed library. Updating this information will only affect new or updated items, existing items will not be moved. The entire placement configuration of the subscribed library will replaced by the new specification.",
                    "$ref": "#/definitions/content.library.subscriptions.update_spec_placement"
                }
            }
        },
        "content.library.subscriptions.update_spec_placement": {
            "type": "object",
            "properties": {
                "folder": {
                    "description": "Virtual machine folder into which the virtual machine template should be placed.",
                    "type": "string"
                },
                "cluster": {
                    "description": "Cluster onto which the virtual machine template should be placed. If {@name #cluster} and {@name #resourcePool} are both specified, {@name #resourcePool} must belong to {@name #cluster}. If {@name #cluster} and {@name #host} are both specified, {@name #host} must be a member of {@name #cluster}. If {@name #resourcePool} or {@name #host} is specified, it is recommended that this {@term field} be {@term unset}.",
                    "type": "string"
                },
                "resource_pool": {
                    "description": "Resource pool into which the virtual machine template should be placed.",
                    "type": "string"
                },
                "host": {
                    "description": "Host onto which the virtual machine template should be placed. If {@name #host} and {@name #resourcePool} are both specified, {@name #resourcePool} must belong to {@name #host}. If {@name #host} and {@name #cluster} are both specified, {@name #host} must be a member of {@name #cluster}.",
                    "type": "string"
                },
                "network": {
                    "description": "Network that backs the virtual Ethernet adapters in the virtual machine template.",
                    "type": "string"
                }
            }
        },
        "content.library.subscriptions.update_spec_vcenter": {
            "type": "object",
            "properties": {
                "hostname": {
                    "description": "The hostname of the subscribed library's vCenter Server.",
                    "type": "string"
                },
                "https_port": {
                    "description": "The HTTPS port of the vCenter Server instance where the subscribed library exists.",
                    "type": "integer",
                    "format": "int64"
                }
            }
        },
        "content.library.subscriptions.vcenter_info": {
            "type": "object",
            "properties": {
                "hostname": {
                    "description": "Hostname of the vCenter Server instance where the subscribed library exists.",
                    "type": "string"
                },
                "https_port": {
                    "description": "The HTTPS port of the vCenter Server instance where the subscribed library exists.",
                    "type": "integer",
                    "format": "int64"
                },
                "server_guid": {
                    "description": "The unique identifier of the vCenter Server where the subscribed library exists.",
                    "type": "string"
                }
            },
            "required": [
                "hostname",
                "server_guid"
            ]
        },
        "content.library.subscriptions_create": {
            "type": "object",
            "properties": {
                "client_token": {
                    "type": "string",
                    "description": "A unique token generated on the client for each creation request. The token should be a universally unique identifier (UUID), for example: {@code b8a2a2e3-2314-43cd-a871-6ede0f429751}. This token can be used to guarantee idempotent creation."
                },
                "spec": {
                    "$ref": "#/definitions/content.library.subscriptions.create_spec",
                    "description": "Specification for the subscription."
                }
            },
            "required": [
                "spec"
            ]
        },
        "content.library.subscriptions_delete": {
            "type": "object",
            "properties": {
                "subscription": {
                    "type": "string",
                    "description": "Subscription identifier."
                }
            },
            "required": [
                "subscription"
            ]
        },
        "content.library.subscriptions_get": {
            "type": "object",
            "properties": {
                "subscription": {
                    "type": "string",
                    "description": "Identifier of the subscription."
                }
            },
            "required": [
                "subscription"
            ]
        },
        "content.library.subscriptions_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "$ref": "#/definitions/content.library.subscriptions.info"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library.subscriptions_update": {
            "type": "object",
            "properties": {
                "subscription": {
                    "type": "string",
                    "description": "subscription identifier."
                },
                "spec": {
                    "$ref": "#/definitions/content.library.subscriptions.update_spec",
                    "description": "Specification of the new property values to set on the subscription."
                }
            },
            "required": [
                "subscription",
                "spec"
            ]
        },
        "content.library_find": {
            "type": "object",
            "properties": {
                "spec": {
                    "$ref": "#/definitions/content.library.find_spec",
                    "description": "Specification describing what properties to filter on."
                }
            },
            "required": [
                "spec"
            ]
        },
        "content.library_model": {
            "type": "object",
            "properties": {
                "id": {
                    "description": "An identifier which uniquely identifies this {@name LibraryModel}.",
                    "type": "string"
                },
                "creation_time": {
                    "description": "The date and time when this library was created.",
                    "type": "string",
                    "format": "date-time"
                },
                "description": {
                    "description": "A human-readable description for this library.",
                    "type": "string"
                },
                "last_modified_time": {
                    "description": "The date and time when this library was last updated. <p> This {@term field} is updated automatically when the library properties are changed. This {@term field} is not affected by adding, removing, or modifying a library item or its content within the library. Tagging the library or syncing the subscribed library does not alter this {@term field}.",
                    "type": "string",
                    "format": "date-time"
                },
                "last_sync_time": {
                    "description": "The date and time when this library was last synchronized. <p> This {@term field} applies only to subscribed libraries. It is updated every time a synchronization is triggered on the library. The value is {@term unset} for a local library.",
                    "type": "string",
                    "format": "date-time"
                },
                "name": {
                    "description": "The name of the library. <p> A Library is identified by a human-readable name. Library names cannot be undefined or an empty string. Names do not have to be unique.",
                    "type": "string"
                },
                "storage_backings": {
                    "description": "The list of default storage backings which are available for this library. <p> A {@link StorageBacking} defines a default storage location which can be used to store files for library items in this library. Some library items, for instance, virtual machine template items, support files that may be distributed across various storage backings. One or more item files may or may not be located on the default storage backing. <p> Multiple default storage locations are not currently supported but may become supported in future releases.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/content.library.storage_backing"
                    }
                },
                "type": {
                    "description": "The type ({@enum.values LibraryModel.LibraryType}) of this library. <p> This value can be used to determine what additional services and information can be available for this library. This {@term field} is not used for the {@code create} and {@code update} {@term operations}. It will always be present in the result of a {@code get} {@term operation}.",
                    "$ref": "#/definitions/content.library_model.library_type"
                },
                "optimization_info": {
                    "description": "Defines various optimizations and optimization parameters applied to this library.",
                    "$ref": "#/definitions/content.library.optimization_info"
                },
                "version": {
                    "description": "A version number which is updated on metadata changes. This value allows clients to detect concurrent updates and prevent accidental clobbering of data. <p> This value represents a number which is incremented every time library properties, such as name or description, are changed. It is not incremented by changes to a library item within the library, including adding or removing items. It is also not affected by tagging the library.",
                    "type": "string"
                },
                "publish_info": {
                    "description": "Defines how this library is published so that it can be subscribed to by a remote subscribed library. <p> The {@link PublishInfo} defines where and how the metadata for this local library is accessible. A local library is only published publically if {@link PublishInfo#published} is {@code true}.",
                    "$ref": "#/definitions/content.library.publish_info"
                },
                "subscription_info": {
                    "description": "Defines the subscription behavior for this Library. <p> The {@link SubscriptionInfo} defines how this subscribed library synchronizes to a remote source. Setting the value will determine the remote source to which the library synchronizes, and how. Changing the subscription will result in synchronizing to a new source. If the new source differs from the old one, the old library items and data will be lost. Setting {@link SubscriptionInfo#automaticSyncEnabled} to false will halt subscription but will not remove existing cached data.",
                    "$ref": "#/definitions/content.library.subscription_info"
                },
                "server_guid": {
                    "description": "The unique identifier of the vCenter server where the library exists.",
                    "type": "string"
                }
            }
        },
        "content.library_model.library_type": {
            "type": "string",
            "description": "The {@name LibraryType} {@term enumerated type} defines the type of a {@link LibraryModel}. <p> The type of a library can be used to determine which additional services can be performed with a library.",
            "enum": [
                "LOCAL",
                "SUBSCRIBED"
            ]
        },
        "content.library_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "$ref": "#/definitions/content.library_model"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.library_update": {
            "type": "object",
            "properties": {
                "update_spec": {
                    "$ref": "#/definitions/content.library_model",
                    "description": "Specification of the new property values to set on the library."
                }
            },
            "required": [
                "update_spec"
            ]
        },
        "content.local_library.create_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "string"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.local_library.destination_spec": {
            "type": "object",
            "properties": {
                "subscription": {
                    "description": "Identifier of the subscription associated with the subscribed library.",
                    "type": "string"
                }
            },
            "required": [
                "subscription"
            ]
        },
        "content.local_library.list_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "value"
            ]
        },
        "content.local_library_create": {
            "type": "object",
            "properties": {
                "client_token": {
                    "type": "string",
                    "description": "A unique token generated on the client for each creation request. The token should be a universally unique identifier (UUID), for example: {@code b8a2a2e3-2314-43cd-a871-6ede0f429751}. This token can be used to guarantee idempotent creation."
                },
                "create_spec": {
                    "$ref": "#/definitions/content.library_model",
                    "description": "Specification for the new local library."
                }
            },
            "required": [
                "create_spec"
            ]
        },
        "content.local_library_publish": {
            "type": "object",
            "properties": {
                "subscriptions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/content.local_library.destination_spec"
                    },
                    "description": "The list of subscriptions to publish this library to."
                }
            }
        },
        "content.local_library_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "$ref": "#/definitions/content.library_model"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.local_library_update": {
            "type": "object",
            "properties": {
                "update_spec": {
                    "$ref": "#/definitions/content.library_model",
                    "description": "Specification of the new property values to set on the local library."
                }
            },
            "required": [
                "update_spec"
            ]
        },
        "content.subscribed_library.create_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "string"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.subscribed_library.list_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "value"
            ]
        },
        "content.subscribed_library.probe_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "$ref": "#/definitions/content.subscribed_library.probe_result"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.subscribed_library.probe_result": {
            "type": "object",
            "properties": {
                "status": {
                    "description": "The status of probe result. This will be one of {@enum.values Status}.",
                    "$ref": "#/definitions/content.subscribed_library.probe_result.status"
                },
                "ssl_thumbprint": {
                    "description": "The SSL thumbprint for the remote endpoint.",
                    "type": "string"
                },
                "error_messages": {
                    "description": "If the probe result is in an error status, this {@term field} will contain the detailed error messages.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/vapi.std.localizable_message"
                    }
                }
            },
            "required": [
                "status",
                "error_messages"
            ]
        },
        "content.subscribed_library.probe_result.status": {
            "type": "string",
            "description": "The {@name Status} {@term enumerated type} defines the error status constants for the probe result.",
            "enum": [
                "SUCCESS",
                "INVALID_URL",
                "TIMED_OUT",
                "HOST_NOT_FOUND",
                "RESOURCE_NOT_FOUND",
                "INVALID_CREDENTIALS",
                "CERTIFICATE_ERROR",
                "UNKNOWN_ERROR"
            ]
        },
        "content.subscribed_library_create": {
            "type": "object",
            "properties": {
                "client_token": {
                    "type": "string",
                    "description": "Unique token generated on the client for each creation request. The token should be a universally unique identifier (UUID), for example: {@code b8a2a2e3-2314-43cd-a871-6ede0f429751}. This token can be used to guarantee idempotent creation."
                },
                "create_spec": {
                    "$ref": "#/definitions/content.library_model",
                    "description": "Specification for the new subscribed library."
                }
            },
            "required": [
                "create_spec"
            ]
        },
        "content.subscribed_library_probe": {
            "type": "object",
            "properties": {
                "subscription_info": {
                    "$ref": "#/definitions/content.library.subscription_info",
                    "description": "The subscription info to be probed."
                }
            },
            "required": [
                "subscription_info"
            ]
        },
        "content.subscribed_library_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "$ref": "#/definitions/content.library_model"
                }
            },
            "required": [
                "value"
            ]
        },
        "content.subscribed_library_update": {
            "type": "object",
            "properties": {
                "update_spec": {
                    "$ref": "#/definitions/content.library_model",
                    "description": "Specification of the new property values to set on the subscribed library."
                }
            },
            "required": [
                "update_spec"
            ]
        },
        "content.type.info": {
            "type": "object",
            "properties": {
                "description": {
                    "description": "A description of the type support offered by the plugin.",
                    "type": "string"
                },
                "name": {
                    "description": "The name of the plugin which provides the type support.",
                    "type": "string"
                },
                "type": {
                    "description": "The type which the plugin supports. <p> To upload a library item of the type supported by the plugin, the {@link ItemModel#type} {@term field} of the item should be set to this value.",
                    "type": "string"
                },
                "vendor": {
                    "description": "The name of the vendor who created the type support plugin.",
                    "type": "string"
                },
                "version": {
                    "description": "The version number of the type support plugin.",
                    "type": "string"
                }
            },
            "required": [
                "description",
                "name",
                "type",
                "vendor",
                "version"
            ]
        },
        "content.type.list_resp": {
            "type": "object",
            "properties": {
                "value": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/content.type.info"
                    }
                }
            },
            "required": [
                "value"
            ]
        },
        "vapi.std.errors.already_exists": {
            "type": "object",
            "properties": {
                "messages": {
                    "description": "Stack of one or more localizable messages for human {@term error} consumers. <p> The message at the top of the stack (first in the list) describes the {@term error} from the perspective of the {@term operation} the client invoked. Each subsequent message in the stack describes the \"cause\" of the prior message.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/vapi.std.localizable_message"
                    }
                },
                "data": {
                    "description": "Data to facilitate clients responding to the {@term operation} reporting a standard {@term error} to indicating that it was unable to complete successfully. <p> {@term Operations} may provide data that clients can use when responding to {@term errors}.  Since the data that clients need may be specific to the context of the {@term operation} reporting the {@term error}, different {@term operations} that report the same {@term error} may provide different data in the {@term error}.  The documentation for each each {@term operation} will describe what, if any, data it provides for each {@term error} it reports. The {@link ArgumentLocations}, {@link FileLocations}, and {@link TransientIndication} {@term structures} are intended as possible values for this {@term field}.  {@link vapi.std.DynamicID} may also be useful as a value for this {@term field} (although that is not its primary purpose).  Some {@term services} may provide their own specific {@term structures} for use as the value of this {@term field} when reporting {@term errors} from their {@term operations}.",
                    "type": "object"
                },
                "error_type": {
                    "description": "Discriminator field to help API consumers identify the structure type.",
                    "$ref": "#/definitions/vapi.std.errors.error.type"
                }
            },
            "required": [
                "messages"
            ]
        },
        "vapi.std.errors.already_exists_error": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "string"
                },
                "value": {
                    "$ref": "#/definitions/vapi.std.errors.already_exists"
                }
            }
        },
        "vapi.std.errors.concurrent_change": {
            "type": "object",
            "properties": {
                "messages": {
                    "description": "Stack of one or more localizable messages for human {@term error} consumers. <p> The message at the top of the stack (first in the list) describes the {@term error} from the perspective of the {@term operation} the client invoked. Each subsequent message in the stack describes the \"cause\" of the prior message.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/vapi.std.localizable_message"
                    }
                },
                "data": {
                    "description": "Data to facilitate clients responding to the {@term operation} reporting a standard {@term error} to indicating that it was unable to complete successfully. <p> {@term Operations} may provide data that clients can use when responding to {@term errors}.  Since the data that clients need may be specific to the context of the {@term operation} reporting the {@term error}, different {@term operations} that report the same {@term error} may provide different data in the {@term error}.  The documentation for each each {@term operation} will describe what, if any, data it provides for each {@term error} it reports. The {@link ArgumentLocations}, {@link FileLocations}, and {@link TransientIndication} {@term structures} are intended as possible values for this {@term field}.  {@link vapi.std.DynamicID} may also be useful as a value for this {@term field} (although that is not its primary purpose).  Some {@term services} may provide their own specific {@term structures} for use as the value of this {@term field} when reporting {@term errors} from their {@term operations}.",
                    "type": "object"
                },
                "error_type": {
                    "description": "Discriminator field to help API consumers identify the structure type.",
                    "$ref": "#/definitions/vapi.std.errors.error.type"
                }
            },
            "required": [
                "messages"
            ]
        },
        "vapi.std.errors.concurrent_change_error": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "string"
                },
                "value": {
                    "$ref": "#/definitions/vapi.std.errors.concurrent_change"
                }
            }
        },
        "vapi.std.errors.error": {
            "type": "object",
            "properties": {
                "messages": {
                    "description": "Stack of one or more localizable messages for human {@term error} consumers. <p> The message at the top of the stack (first in the list) describes the {@term error} from the perspective of the {@term operation} the client invoked. Each subsequent message in the stack describes the \"cause\" of the prior message.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/vapi.std.localizable_message"
                    }
                },
                "data": {
                    "description": "Data to facilitate clients responding to the {@term operation} reporting a standard {@term error} to indicating that it was unable to complete successfully. <p> {@term Operations} may provide data that clients can use when responding to {@term errors}.  Since the data that clients need may be specific to the context of the {@term operation} reporting the {@term error}, different {@term operations} that report the same {@term error} may provide different data in the {@term error}.  The documentation for each each {@term operation} will describe what, if any, data it provides for each {@term error} it reports. The {@link ArgumentLocations}, {@link FileLocations}, and {@link TransientIndication} {@term structures} are intended as possible values for this {@term field}.  {@link vapi.std.DynamicID} may also be useful as a value for this {@term field} (although that is not its primary purpose).  Some {@term services} may provide their own specific {@term structures} for use as the value of this {@term field} when reporting {@term errors} from their {@term operations}.",
                    "type": "object"
                },
                "error_type": {
                    "description": "Discriminator field to help API consumers identify the structure type.",
                    "$ref": "#/definitions/vapi.std.errors.error.type"
                }
            },
            "required": [
                "messages"
            ]
        },
        "vapi.std.errors.error.type": {
            "type": "string",
            "description": "Enumeration of all standard errors. Used as discriminator in protocols that have no standard means for transporting the error type, e.g. REST.",
            "enum": [
                "ERROR",
                "ALREADY_EXISTS",
                "ALREADY_IN_DESIRED_STATE",
                "CANCELED",
                "CONCURRENT_CHANGE",
                "FEATURE_IN_USE",
                "INTERNAL_SERVER_ERROR",
                "INVALID_ARGUMENT",
                "INVALID_ELEMENT_CONFIGURATION",
                "INVALID_ELEMENT_TYPE",
                "INVALID_REQUEST",
                "NOT_ALLOWED_IN_CURRENT_STATE",
                "NOT_FOUND",
                "OPERATION_NOT_FOUND",
                "RESOURCE_BUSY",
                "RESOURCE_IN_USE",
                "RESOURCE_INACCESSIBLE",
                "SERVICE_UNAVAILABLE",
                "TIMED_OUT",
                "UNABLE_TO_ALLOCATE_RESOURCE",
                "UNAUTHENTICATED",
                "UNAUTHORIZED",
                "UNEXPECTED_INPUT",
                "UNSUPPORTED",
                "UNVERIFIED_PEER"
            ]
        },
        "vapi.std.errors.error_error": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "string"
                },
                "value": {
                    "$ref": "#/definitions/vapi.std.errors.error"
                }
            }
        },
        "vapi.std.errors.invalid_argument": {
            "type": "object",
            "properties": {
                "messages": {
                    "description": "Stack of one or more localizable messages for human {@term error} consumers. <p> The message at the top of the stack (first in the list) describes the {@term error} from the perspective of the {@term operation} the client invoked. Each subsequent message in the stack describes the \"cause\" of the prior message.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/vapi.std.localizable_message"
                    }
                },
                "data": {
                    "description": "Data to facilitate clients responding to the {@term operation} reporting a standard {@term error} to indicating that it was unable to complete successfully. <p> {@term Operations} may provide data that clients can use when responding to {@term errors}.  Since the data that clients need may be specific to the context of the {@term operation} reporting the {@term error}, different {@term operations} that report the same {@term error} may provide different data in the {@term error}.  The documentation for each each {@term operation} will describe what, if any, data it provides for each {@term error} it reports. The {@link ArgumentLocations}, {@link FileLocations}, and {@link TransientIndication} {@term structures} are intended as possible values for this {@term field}.  {@link vapi.std.DynamicID} may also be useful as a value for this {@term field} (although that is not its primary purpose).  Some {@term services} may provide their own specific {@term structures} for use as the value of this {@term field} when reporting {@term errors} from their {@term operations}.",
                    "type": "object"
                },
                "error_type": {
                    "description": "Discriminator field to help API consumers identify the structure type.",
                    "$ref": "#/definitions/vapi.std.errors.error.type"
                }
            },
            "required": [
                "messages"
            ]
        },
        "vapi.std.errors.invalid_argument_error": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "string"
                },
                "value": {
                    "$ref": "#/definitions/vapi.std.errors.invalid_argument"
                }
            }
        },
        "vapi.std.errors.invalid_element_configuration": {
            "type": "object",
            "properties": {
                "messages": {
                    "description": "Stack of one or more localizable messages for human {@term error} consumers. <p> The message at the top of the stack (first in the list) describes the {@term error} from the perspective of the {@term operation} the client invoked. Each subsequent message in the stack describes the \"cause\" of the prior message.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/vapi.std.localizable_message"
                    }
                },
                "data": {
                    "description": "Data to facilitate clients responding to the {@term operation} reporting a standard {@term error} to indicating that it was unable to complete successfully. <p> {@term Operations} may provide data that clients can use when responding to {@term errors}.  Since the data that clients need may be specific to the context of the {@term operation} reporting the {@term error}, different {@term operations} that report the same {@term error} may provide different data in the {@term error}.  The documentation for each each {@term operation} will describe what, if any, data it provides for each {@term error} it reports. The {@link ArgumentLocations}, {@link FileLocations}, and {@link TransientIndication} {@term structures} are intended as possible values for this {@term field}.  {@link vapi.std.DynamicID} may also be useful as a value for this {@term field} (although that is not its primary purpose).  Some {@term services} may provide their own specific {@term structures} for use as the value of this {@term field} when reporting {@term errors} from their {@term operations}.",
                    "type": "object"
                },
                "error_type": {
                    "description": "Discriminator field to help API consumers identify the structure type.",
                    "$ref": "#/definitions/vapi.std.errors.error.type"
                }
            },
            "required": [
                "messages"
            ]
        },
        "vapi.std.errors.invalid_element_configuration_error": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "string"
                },
                "value": {
                    "$ref": "#/definitions/vapi.std.errors.invalid_element_configuration"
                }
            }
        },
        "vapi.std.errors.invalid_element_type": {
            "type": "object",
            "properties": {
                "messages": {
                    "description": "Stack of one or more localizable messages for human {@term error} consumers. <p> The message at the top of the stack (first in the list) describes the {@term error} from the perspective of the {@term operation} the client invoked. Each subsequent message in the stack describes the \"cause\" of the prior message.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/vapi.std.localizable_message"
                    }
                },
                "data": {
                    "description": "Data to facilitate clients responding to the {@term operation} reporting a standard {@term error} to indicating that it was unable to complete successfully. <p> {@term Operations} may provide data that clients can use when responding to {@term errors}.  Since the data that clients need may be specific to the context of the {@term operation} reporting the {@term error}, different {@term operations} that report the same {@term error} may provide different data in the {@term error}.  The documentation for each each {@term operation} will describe what, if any, data it provides for each {@term error} it reports. The {@link ArgumentLocations}, {@link FileLocations}, and {@link TransientIndication} {@term structures} are intended as possible values for this {@term field}.  {@link vapi.std.DynamicID} may also be useful as a value for this {@term field} (although that is not its primary purpose).  Some {@term services} may provide their own specific {@term structures} for use as the value of this {@term field} when reporting {@term errors} from their {@term operations}.",
                    "type": "object"
                },
                "error_type": {
                    "description": "Discriminator field to help API consumers identify the structure type.",
                    "$ref": "#/definitions/vapi.std.errors.error.type"
                }
            },
            "required": [
                "messages"
            ]
        },
        "vapi.std.errors.invalid_element_type_error": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "string"
                },
                "value": {
                    "$ref": "#/definitions/vapi.std.errors.invalid_element_type"
                }
            }
        },
        "vapi.std.errors.not_allowed_in_current_state": {
            "type": "object",
            "properties": {
                "messages": {
                    "description": "Stack of one or more localizable messages for human {@term error} consumers. <p> The message at the top of the stack (first in the list) describes the {@term error} from the perspective of the {@term operation} the client invoked. Each subsequent message in the stack describes the \"cause\" of the prior message.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/vapi.std.localizable_message"
                    }
                },
                "data": {
                    "description": "Data to facilitate clients responding to the {@term operation} reporting a standard {@term error} to indicating that it was unable to complete successfully. <p> {@term Operations} may provide data that clients can use when responding to {@term errors}.  Since the data that clients need may be specific to the context of the {@term operation} reporting the {@term error}, different {@term operations} that report the same {@term error} may provide different data in the {@term error}.  The documentation for each each {@term operation} will describe what, if any, data it provides for each {@term error} it reports. The {@link ArgumentLocations}, {@link FileLocations}, and {@link TransientIndication} {@term structures} are intended as possible values for this {@term field}.  {@link vapi.std.DynamicID} may also be useful as a value for this {@term field} (although that is not its primary purpose).  Some {@term services} may provide their own specific {@term structures} for use as the value of this {@term field} when reporting {@term errors} from their {@term operations}.",
                    "type": "object"
                },
                "error_type": {
                    "description": "Discriminator field to help API consumers identify the structure type.",
                    "$ref": "#/definitions/vapi.std.errors.error.type"
                }
            },
            "required": [
                "messages"
            ]
        },
        "vapi.std.errors.not_allowed_in_current_state_error": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "string"
                },
                "value": {
                    "$ref": "#/definitions/vapi.std.errors.not_allowed_in_current_state"
                }
            }
        },
        "vapi.std.errors.not_found": {
            "type": "object",
            "properties": {
                "messages": {
                    "description": "Stack of one or more localizable messages for human {@term error} consumers. <p> The message at the top of the stack (first in the list) describes the {@term error} from the perspective of the {@term operation} the client invoked. Each subsequent message in the stack describes the \"cause\" of the prior message.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/vapi.std.localizable_message"
                    }
                },
                "data": {
                    "description": "Data to facilitate clients responding to the {@term operation} reporting a standard {@term error} to indicating that it was unable to complete successfully. <p> {@term Operations} may provide data that clients can use when responding to {@term errors}.  Since the data that clients need may be specific to the context of the {@term operation} reporting the {@term error}, different {@term operations} that report the same {@term error} may provide different data in the {@term error}.  The documentation for each each {@term operation} will describe what, if any, data it provides for each {@term error} it reports. The {@link ArgumentLocations}, {@link FileLocations}, and {@link TransientIndication} {@term structures} are intended as possible values for this {@term field}.  {@link vapi.std.DynamicID} may also be useful as a value for this {@term field} (although that is not its primary purpose).  Some {@term services} may provide their own specific {@term structures} for use as the value of this {@term field} when reporting {@term errors} from their {@term operations}.",
                    "type": "object"
                },
                "error_type": {
                    "description": "Discriminator field to help API consumers identify the structure type.",
                    "$ref": "#/definitions/vapi.std.errors.error.type"
                }
            },
            "required": [
                "messages"
            ]
        },
        "vapi.std.errors.not_found_error": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "string"
                },
                "value": {
                    "$ref": "#/definitions/vapi.std.errors.not_found"
                }
            }
        },
        "vapi.std.errors.resource_busy": {
            "type": "object",
            "properties": {
                "messages": {
                    "description": "Stack of one or more localizable messages for human {@term error} consumers. <p> The message at the top of the stack (first in the list) describes the {@term error} from the perspective of the {@term operation} the client invoked. Each subsequent message in the stack describes the \"cause\" of the prior message.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/vapi.std.localizable_message"
                    }
                },
                "data": {
                    "description": "Data to facilitate clients responding to the {@term operation} reporting a standard {@term error} to indicating that it was unable to complete successfully. <p> {@term Operations} may provide data that clients can use when responding to {@term errors}.  Since the data that clients need may be specific to the context of the {@term operation} reporting the {@term error}, different {@term operations} that report the same {@term error} may provide different data in the {@term error}.  The documentation for each each {@term operation} will describe what, if any, data it provides for each {@term error} it reports. The {@link ArgumentLocations}, {@link FileLocations}, and {@link TransientIndication} {@term structures} are intended as possible values for this {@term field}.  {@link vapi.std.DynamicID} may also be useful as a value for this {@term field} (although that is not its primary purpose).  Some {@term services} may provide their own specific {@term structures} for use as the value of this {@term field} when reporting {@term errors} from their {@term operations}.",
                    "type": "object"
                },
                "error_type": {
                    "description": "Discriminator field to help API consumers identify the structure type.",
                    "$ref": "#/definitions/vapi.std.errors.error.type"
                }
            },
            "required": [
                "messages"
            ]
        },
        "vapi.std.errors.resource_busy_error": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "string"
                },
                "value": {
                    "$ref": "#/definitions/vapi.std.errors.resource_busy"
                }
            }
        },
        "vapi.std.errors.resource_inaccessible": {
            "type": "object",
            "properties": {
                "messages": {
                    "description": "Stack of one or more localizable messages for human {@term error} consumers. <p> The message at the top of the stack (first in the list) describes the {@term error} from the perspective of the {@term operation} the client invoked. Each subsequent message in the stack describes the \"cause\" of the prior message.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/vapi.std.localizable_message"
                    }
                },
                "data": {
                    "description": "Data to facilitate clients responding to the {@term operation} reporting a standard {@term error} to indicating that it was unable to complete successfully. <p> {@term Operations} may provide data that clients can use when responding to {@term errors}.  Since the data that clients need may be specific to the context of the {@term operation} reporting the {@term error}, different {@term operations} that report the same {@term error} may provide different data in the {@term error}.  The documentation for each each {@term operation} will describe what, if any, data it provides for each {@term error} it reports. The {@link ArgumentLocations}, {@link FileLocations}, and {@link TransientIndication} {@term structures} are intended as possible values for this {@term field}.  {@link vapi.std.DynamicID} may also be useful as a value for this {@term field} (although that is not its primary purpose).  Some {@term services} may provide their own specific {@term structures} for use as the value of this {@term field} when reporting {@term errors} from their {@term operations}.",
                    "type": "object"
                },
                "error_type": {
                    "description": "Discriminator field to help API consumers identify the structure type.",
                    "$ref": "#/definitions/vapi.std.errors.error.type"
                }
            },
            "required": [
                "messages"
            ]
        },
        "vapi.std.errors.resource_inaccessible_error": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "string"
                },
                "value": {
                    "$ref": "#/definitions/vapi.std.errors.resource_inaccessible"
                }
            }
        },
        "vapi.std.errors.unauthenticated": {
            "type": "object",
            "properties": {
                "challenge": {
                    "description": "Indicates the authentication challenges applicable to the target API provider. It can be used by a client to discover the correct authentication scheme to use. The exact syntax of the value is defined by the specific provider, the protocol and authentication schemes used. <p> For example, a provider using REST may adhere to the WWW-Authenticate HTTP header specification, RFC7235, section 4.1. In this case an example challenge value may be: SIGN realm=\"27da1358-2ba4-11e9-b210-d663bd873d93\",sts=\"http://vcenter/sso?vsphere.local\", Basic realm=\"vCenter\"",
                    "type": "string"
                },
                "messages": {
                    "description": "Stack of one or more localizable messages for human {@term error} consumers. <p> The message at the top of the stack (first in the list) describes the {@term error} from the perspective of the {@term operation} the client invoked. Each subsequent message in the stack describes the \"cause\" of the prior message.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/vapi.std.localizable_message"
                    }
                },
                "data": {
                    "description": "Data to facilitate clients responding to the {@term operation} reporting a standard {@term error} to indicating that it was unable to complete successfully. <p> {@term Operations} may provide data that clients can use when responding to {@term errors}.  Since the data that clients need may be specific to the context of the {@term operation} reporting the {@term error}, different {@term operations} that report the same {@term error} may provide different data in the {@term error}.  The documentation for each each {@term operation} will describe what, if any, data it provides for each {@term error} it reports. The {@link ArgumentLocations}, {@link FileLocations}, and {@link TransientIndication} {@term structures} are intended as possible values for this {@term field}.  {@link vapi.std.DynamicID} may also be useful as a value for this {@term field} (although that is not its primary purpose).  Some {@term services} may provide their own specific {@term structures} for use as the value of this {@term field} when reporting {@term errors} from their {@term operations}.",
                    "type": "object"
                },
                "error_type": {
                    "description": "Discriminator field to help API consumers identify the structure type.",
                    "$ref": "#/definitions/vapi.std.errors.error.type"
                }
            },
            "required": [
                "messages"
            ]
        },
        "vapi.std.errors.unauthenticated_error": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "string"
                },
                "value": {
                    "$ref": "#/definitions/vapi.std.errors.unauthenticated"
                }
            }
        },
        "vapi.std.errors.unauthorized": {
            "type": "object",
            "properties": {
                "messages": {
                    "description": "Stack of one or more localizable messages for human {@term error} consumers. <p> The message at the top of the stack (first in the list) describes the {@term error} from the perspective of the {@term operation} the client invoked. Each subsequent message in the stack describes the \"cause\" of the prior message.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/vapi.std.localizable_message"
                    }
                },
                "data": {
                    "description": "Data to facilitate clients responding to the {@term operation} reporting a standard {@term error} to indicating that it was unable to complete successfully. <p> {@term Operations} may provide data that clients can use when responding to {@term errors}.  Since the data that clients need may be specific to the context of the {@term operation} reporting the {@term error}, different {@term operations} that report the same {@term error} may provide different data in the {@term error}.  The documentation for each each {@term operation} will describe what, if any, data it provides for each {@term error} it reports. The {@link ArgumentLocations}, {@link FileLocations}, and {@link TransientIndication} {@term structures} are intended as possible values for this {@term field}.  {@link vapi.std.DynamicID} may also be useful as a value for this {@term field} (although that is not its primary purpose).  Some {@term services} may provide their own specific {@term structures} for use as the value of this {@term field} when reporting {@term errors} from their {@term operations}.",
                    "type": "object"
                },
                "error_type": {
                    "description": "Discriminator field to help API consumers identify the structure type.",
                    "$ref": "#/definitions/vapi.std.errors.error.type"
                }
            },
            "required": [
                "messages"
            ]
        },
        "vapi.std.errors.unauthorized_error": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "string"
                },
                "value": {
                    "$ref": "#/definitions/vapi.std.errors.unauthorized"
                }
            }
        },
        "vapi.std.errors.unsupported": {
            "type": "object",
            "properties": {
                "messages": {
                    "description": "Stack of one or more localizable messages for human {@term error} consumers. <p> The message at the top of the stack (first in the list) describes the {@term error} from the perspective of the {@term operation} the client invoked. Each subsequent message in the stack describes the \"cause\" of the prior message.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/vapi.std.localizable_message"
                    }
                },
                "data": {
                    "description": "Data to facilitate clients responding to the {@term operation} reporting a standard {@term error} to indicating that it was unable to complete successfully. <p> {@term Operations} may provide data that clients can use when responding to {@term errors}.  Since the data that clients need may be specific to the context of the {@term operation} reporting the {@term error}, different {@term operations} that report the same {@term error} may provide different data in the {@term error}.  The documentation for each each {@term operation} will describe what, if any, data it provides for each {@term error} it reports. The {@link ArgumentLocations}, {@link FileLocations}, and {@link TransientIndication} {@term structures} are intended as possible values for this {@term field}.  {@link vapi.std.DynamicID} may also be useful as a value for this {@term field} (although that is not its primary purpose).  Some {@term services} may provide their own specific {@term structures} for use as the value of this {@term field} when reporting {@term errors} from their {@term operations}.",
                    "type": "object"
                },
                "error_type": {
                    "description": "Discriminator field to help API consumers identify the structure type.",
                    "$ref": "#/definitions/vapi.std.errors.error.type"
                }
            },
            "required": [
                "messages"
            ]
        },
        "vapi.std.errors.unsupported_error": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "string"
                },
                "value": {
                    "$ref": "#/definitions/vapi.std.errors.unsupported"
                }
            }
        },
        "vapi.std.localizable_message": {
            "type": "object",
            "properties": {
                "id": {
                    "description": "Unique identifier of the localizable string or message template. <p> This identifier is typically used to retrieve a locale-specific string or message template from a message catalog.",
                    "type": "string"
                },
                "default_message": {
                    "description": "The value of this localizable string or message template in the {@code en_US} (English) locale.  If {@link #id} refers to a message template, the default message will contain the substituted arguments. This value can be used by clients that do not need to display strings and messages in the native language of the user.  It could also be used as a fallback if a client is unable to access the appropriate message catalog.",
                    "type": "string"
                },
                "args": {
                    "description": "Positional arguments to be substituted into the message template. This list will be empty if the message uses named arguments or has no arguments.",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "params": {
                    "description": "Named arguments to be substituted into the message template.",
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "key": {
                                "type": "string"
                            },
                            "value": {
                                "$ref": "#/definitions/vapi.std.localization_param"
                            }
                        }
                    }
                },
                "localized": {
                    "description": "Localized string value as per request requirements.",
                    "type": "string"
                }
            },
            "required": [
                "id",
                "default_message",
                "args"
            ]
        },
        "vapi.std.localization_param": {
            "type": "object",
            "properties": {
                "s": {
                    "description": "{@term String} value associated with the parameter.",
                    "type": "string"
                },
                "dt": {
                    "description": "Date and time value associated with the parameter. Use the {@name #format} {@term field} to specify date and time display style.",
                    "type": "string",
                    "format": "date-time"
                },
                "i": {
                    "description": "{@term long} value associated with the parameter.",
                    "type": "integer",
                    "format": "int64"
                },
                "d": {
                    "description": "The {@term double} value associated with the parameter. The number of displayed fractional digits is changed via {@name #precision} {@term field}.",
                    "type": "number",
                    "format": "double"
                },
                "l": {
                    "description": "Nested localizable value associated with the parameter. This is useful construct to convert to human readable localized form {@term enumerated type} and {@term boolean} values. It can also be used for proper handling of pluralization and gender forms in localization. Recursive {@name NestedLocalizableMessage} instances can be used for localizing short lists of items.",
                    "$ref": "#/definitions/vapi.std.nested_localizable_message"
                },
                "format": {
                    "description": "Format associated with the date and time value in {@name #dt} {@term field}. The {@term enumeration value} {@code SHORT_DATETIME} will be used as default.",
                    "$ref": "#/definitions/vapi.std.localization_param.date_time_format"
                },
                "precision": {
                    "description": "Number of fractional digits to include in formatted {@term double} value.",
                    "type": "integer",
                    "format": "int64"
                }
            }
        },
        "vapi.std.localization_param.date_time_format": {
            "type": "string",
            "description": "The {@name DateTimeFormat} {@term enumerated type} lists possible date and time formatting options. It combines the Unicode CLDR format types - full, long, medium and short with 3 different presentations - date only, time only and combined date and time presentation.",
            "enum": [
                "SHORT_DATE",
                "MED_DATE",
                "LONG_DATE",
                "FULL_DATE",
                "SHORT_TIME",
                "MED_TIME",
                "LONG_TIME",
                "FULL_TIME",
                "SHORT_DATE_TIME",
                "MED_DATE_TIME",
                "LONG_DATE_TIME",
                "FULL_DATE_TIME"
            ]
        },
        "vapi.std.nested_localizable_message": {
            "type": "object",
            "properties": {
                "id": {
                    "description": "Unique identifier of the localizable string or message template. <p> This identifier is typically used to retrieve a locale-specific string or message template from a message catalog.",
                    "type": "string"
                },
                "params": {
                    "description": "Named Arguments to be substituted into the message template.",
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "key": {
                                "type": "string"
                            },
                            "value": {
                                "$ref": "#/definitions/vapi.std.localization_param"
                            }
                        }
                    }
                }
            },
            "required": [
                "id"
            ]
        }
    }
}
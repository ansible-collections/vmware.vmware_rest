#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright: (c) 2021, Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
# template: header.j2
# This module is autogenerated by vmware_rest_code_generator.
# See: https://github.com/ansible-collections/vmware_rest_code_generator
from __future__ import absolute_import, division, print_function

__metaclass__ = type


DOCUMENTATION = r"""
module: appliance_networking
short_description: Reset and restarts network configuration on all interfaces, also
  this will renew the DHCP lease for DHCP IP address.
description: Reset and restarts network configuration on all interfaces, also this
  will renew the DHCP lease for DHCP IP address.
options:
  SSO_password:
    description:
    - vCenter Server SSO administrator Password Required with I(state=['change'])
    type: str
  SSO_user:
    description:
    - vCenter Server SSO administrator username Required with I(state=['change'])
    type: str
  dns:
    description:
    - DNS Configuration to set for the machine Required with I(state=['change'])
    - 'Valid attributes are:'
    - ' - C(mode) (str): C(dns_server_mode) Describes DNS Server source (DHCP,static)
      ([''change''])'
    - '   - Accepted values:'
    - '     - dhcp'
    - '     - is_static'
    - ' - C(servers) (list): List of the currently used DNS servers. ([''change''])'
    type: dict
  hostname:
    description:
    - New hostname to assign to the management network of vCenter appliance Required
      with I(state=['change'])
    type: str
  ipv4:
    description:
    - IPv4 Configuration to set for the machine Required with I(state=['change'])
    - 'Valid attributes are:'
    - ' - C(mode) (str): The C(mode) defines different IPv4 address assignment modes.
      ([''change''])'
    - '   - Accepted values:'
    - '     - DHCP'
    - '     - STATIC'
    - '     - UNCONFIGURED'
    - ' - C(address) (str): The IPv4 address, for example, "10.20.80.191". ([''change''])'
    - ' - C(prefix) (int): The IPv4 CIDR prefix, for example, 24.  See http://www.oav.net/mirrors/cidr.html
      for netmask-to-prefix conversion. ([''change''])'
    - ' - C(default_gateway) (str): The IPv4 address of the default gateway. This
      configures the global default gateway on the appliance with the specified gateway
      address and interface. This gateway replaces the existing default gateway configured
      on the appliance. However, if the gateway address is link-local, then it is
      added for that interface. This does not support configuration of multiple global
      default gateways through different interfaces. ([''change''])'
    type: dict
  ipv6:
    description:
    - IPv6 Configuration to set for the machine Required with I(state=['change'])
    - 'Valid attributes are:'
    - ' - C(dhcp) (bool): An address will be assigned by a DHCP server. ([''change''])'
    - ' - C(autoconf) (bool): An address will be assigned by Stateless Address Autoconfiguration
      (SLAAC). ([''change''])'
    - ' - C(addresses) (list): The list of addresses to be statically assigned. ([''change''])'
    - ' - C(default_gateway) (str): The default gateway for static IP address assignment.
      This configures the global IPv6 default gateway on the appliance with the specified
      gateway address and interface. This gateway replaces the existing default gateway
      configured on the appliance. However, if the gateway address is link-local,
      then it is added for that interface. This does not support configuration of
      multiple global default gateways through different interfaces. ([''change''])'
    type: dict
  ipv6_enabled:
    description:
    - IPv6 Enabled or not
    type: bool
  session_timeout:
    description:
    - 'Timeout settings for client session. '
    - 'The maximal number of seconds for the whole operation including connection
      establishment, request sending and response. '
    - The default value is 300s.
    type: float
    version_added: 2.1.0
  state:
    choices:
    - change
    - present
    - reset
    default: present
    description: []
    type: str
  vcenter_hostname:
    description:
    - The hostname or IP address of the vSphere vCenter
    - If the value is not specified in the task, the value of environment variable
      C(VMWARE_HOST) will be used instead.
    required: true
    type: str
  vcenter_password:
    description:
    - The vSphere vCenter password
    - If the value is not specified in the task, the value of environment variable
      C(VMWARE_PASSWORD) will be used instead.
    required: true
    type: str
  vcenter_rest_log_file:
    description:
    - 'You can use this optional parameter to set the location of a log file. '
    - 'This file will be used to record the HTTP REST interaction. '
    - 'The file will be stored on the host that run the module. '
    - 'If the value is not specified in the task, the value of '
    - environment variable C(VMWARE_REST_LOG_FILE) will be used instead.
    type: str
  vcenter_username:
    description:
    - The vSphere vCenter username
    - If the value is not specified in the task, the value of environment variable
      C(VMWARE_USER) will be used instead.
    required: true
    type: str
  vcenter_validate_certs:
    default: true
    description:
    - Allows connection when SSL certificates are not valid. Set to C(false) when
      certificates are not trusted.
    - If the value is not specified in the task, the value of environment variable
      C(VMWARE_VALIDATE_CERTS) will be used instead.
    type: bool
author:
- Ansible Cloud Team (@ansible-collections)
version_added: 2.0.0
requirements:
- vSphere 7.0.2 or greater
- python >= 3.6
- aiohttp
notes:
- Tested on vSphere 7.0.2
"""

EXAMPLES = r"""
"""

RETURN = r"""
"""

# This structure describes the format of the data expected by the end-points
PAYLOAD_FORMAT = {
    "update": {"query": {}, "body": {"ipv6_enabled": "ipv6_enabled"}, "path": {}},
    "reset": {"query": {}, "body": {}, "path": {}},
    "change": {
        "query": {},
        "body": {
            "SSO_password": "SSO_password",
            "SSO_user": "SSO_user",
            "dns": "dns",
            "hostname": "hostname",
            "ipv4": "ipv4",
            "ipv6": "ipv6",
        },
        "path": {},
    },
}  # pylint: disable=line-too-long

import json
import socket
from ansible.module_utils.basic import env_fallback

try:
    from ansible_collections.cloud.common.plugins.module_utils.turbo.exceptions import (
        EmbeddedModuleFailure,
    )
    from ansible_collections.cloud.common.plugins.module_utils.turbo.module import (
        AnsibleTurboModule as AnsibleModule,
    )

    AnsibleModule.collection_name = "vmware.vmware_rest"
except ImportError:
    from ansible.module_utils.basic import AnsibleModule
from ansible_collections.vmware.vmware_rest.plugins.module_utils.vmware_rest import (
    build_full_device_list,
    exists,
    gen_args,
    get_device_info,
    get_subdevice_type,
    list_devices,
    open_session,
    prepare_payload,
    update_changed_flag,
    session_timeout,
)


def prepare_argument_spec():
    argument_spec = {
        "vcenter_hostname": dict(
            type="str", required=True, fallback=(env_fallback, ["VMWARE_HOST"]),
        ),
        "vcenter_username": dict(
            type="str", required=True, fallback=(env_fallback, ["VMWARE_USER"]),
        ),
        "vcenter_password": dict(
            type="str",
            required=True,
            no_log=True,
            fallback=(env_fallback, ["VMWARE_PASSWORD"]),
        ),
        "vcenter_validate_certs": dict(
            type="bool",
            required=False,
            default=True,
            fallback=(env_fallback, ["VMWARE_VALIDATE_CERTS"]),
        ),
        "vcenter_rest_log_file": dict(
            type="str",
            required=False,
            fallback=(env_fallback, ["VMWARE_REST_LOG_FILE"]),
        ),
        "session_timeout": dict(
            type="float",
            required=False,
            fallback=(env_fallback, ["VMWARE_SESSION_TIMEOUT"]),
        ),
    }

    argument_spec["SSO_password"] = {"no_log": True, "type": "str"}
    argument_spec["SSO_user"] = {"type": "str"}
    argument_spec["dns"] = {"type": "dict"}
    argument_spec["hostname"] = {"type": "str"}
    argument_spec["ipv4"] = {"type": "dict"}
    argument_spec["ipv6"] = {"type": "dict"}
    argument_spec["ipv6_enabled"] = {"type": "bool"}
    argument_spec["state"] = {
        "type": "str",
        "choices": ["change", "present", "reset"],
        "default": "present",
    }

    return argument_spec


async def main():
    required_if = list([])

    module_args = prepare_argument_spec()
    module = AnsibleModule(
        argument_spec=module_args, required_if=required_if, supports_check_mode=True
    )
    if not module.params["vcenter_hostname"]:
        module.fail_json("vcenter_hostname cannot be empty")
    if not module.params["vcenter_username"]:
        module.fail_json("vcenter_username cannot be empty")
    if not module.params["vcenter_password"]:
        module.fail_json("vcenter_password cannot be empty")
    try:
        session = await open_session(
            vcenter_hostname=module.params["vcenter_hostname"],
            vcenter_username=module.params["vcenter_username"],
            vcenter_password=module.params["vcenter_password"],
            validate_certs=module.params["vcenter_validate_certs"],
            log_file=module.params["vcenter_rest_log_file"],
        )
    except EmbeddedModuleFailure as err:
        module.fail_json(err.get_message())
    result = await entry_point(module, session)
    module.exit_json(**result)


# template: default_module.j2
def build_url(params):
    return ("https://{vcenter_hostname}" "/api/appliance/networking").format(**params)


async def entry_point(module, session):

    if module.params["state"] == "present":
        if "_create" in globals():
            operation = "create"
        else:
            operation = "update"
    elif module.params["state"] == "absent":
        operation = "delete"
    else:
        operation = module.params["state"]

    func = globals()["_" + operation]

    return await func(module.params, session)


async def _change(params, session):
    _in_query_parameters = PAYLOAD_FORMAT["change"]["query"].keys()
    payload = prepare_payload(params, PAYLOAD_FORMAT["change"])
    subdevice_type = get_subdevice_type(
        "/api/appliance/networking?action=change&vmw-task=true"
    )
    if subdevice_type and not params[subdevice_type]:
        _json = await exists(params, session, build_url(params))
        if _json:
            params[subdevice_type] = _json["id"]
    _url = (
        "https://{vcenter_hostname}"
        # aa
        "/api/appliance/networking?action=change&vmw-task=true"
    ).format(**params) + gen_args(params, _in_query_parameters)
    async with session.post(_url, json=payload, **session_timeout(params)) as resp:
        try:
            if resp.headers["Content-Type"] == "application/json":
                _json = await resp.json()
        except KeyError:
            _json = {}
        if "value" not in _json:  # 7.0.2
            _json = {"value": _json}

        return await update_changed_flag(_json, resp.status, "change")


async def _reset(params, session):
    _in_query_parameters = PAYLOAD_FORMAT["reset"]["query"].keys()
    payload = prepare_payload(params, PAYLOAD_FORMAT["reset"])
    subdevice_type = get_subdevice_type("/api/appliance/networking?action=reset")
    if subdevice_type and not params[subdevice_type]:
        _json = await exists(params, session, build_url(params))
        if _json:
            params[subdevice_type] = _json["id"]
    _url = (
        "https://{vcenter_hostname}"
        # aa
        "/api/appliance/networking?action=reset"
    ).format(**params) + gen_args(params, _in_query_parameters)
    async with session.post(_url, json=payload, **session_timeout(params)) as resp:
        try:
            if resp.headers["Content-Type"] == "application/json":
                _json = await resp.json()
        except KeyError:
            _json = {}
        if "value" not in _json:  # 7.0.2
            _json = {"value": _json}

        return await update_changed_flag(_json, resp.status, "reset")


async def _update(params, session):
    payload = prepare_payload(params, PAYLOAD_FORMAT["update"])
    _url = ("https://{vcenter_hostname}" "/api/appliance/networking").format(**params)
    async with session.get(_url, **session_timeout(params)) as resp:
        _json = await resp.json()
        if "value" in _json:
            value = _json["value"]
        else:  # 7.0.2 and greater
            value = _json
        for k, v in value.items():
            if k in payload:
                if isinstance(payload[k], dict) and isinstance(v, dict):
                    for _k in list(payload[k].keys()):
                        if payload[k][_k] == v.get(_k):
                            del payload[k][_k]
                if payload[k] == v or payload[k] == {}:
                    del payload[k]
            elif "spec" in payload:  # 7.0.2 <
                if k in payload["spec"] and payload["spec"][k] == v:
                    del payload["spec"][k]

        if payload == {} or payload == {"spec": {}}:
            # Nothing has changed
            if "value" not in _json:  # 7.0.2
                _json = {"value": _json}
            _json["id"] = params.get("None")
            return await update_changed_flag(_json, resp.status, "get")
    async with session.patch(_url, json=payload, **session_timeout(params)) as resp:
        try:
            if resp.headers["Content-Type"] == "application/json":
                _json = await resp.json()
        except KeyError:
            _json = {}
        if "value" not in _json:  # 7.0.2
            _json = {"value": _json}

        # e.g: content_configuration
        if not _json and resp.status == 204:
            async with session.get(_url, **session_timeout(params)) as resp_get:
                _json_get = await resp_get.json()
                if _json_get:
                    _json = _json_get

        _json["id"] = params.get("None")
        return await update_changed_flag(_json, resp.status, "update")


if __name__ == "__main__":
    import asyncio

    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())

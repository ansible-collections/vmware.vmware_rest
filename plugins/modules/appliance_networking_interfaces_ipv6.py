#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright: (c) 2021, Ansible Project
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
# template: header.j2
# This module is autogenerated using the ansible.content_builder.
# See: https://github.com/ansible-community/ansible.content_builder


DOCUMENTATION = r"""
module: appliance_networking_interfaces_ipv6
short_description: Set IPv6 network configuration for specific interface.
description: Set IPv6 network configuration for specific interface.
options:
    addresses:
        description:
        - The list of addresses to be statically assigned. This parameter is mandatory.
        - 'Valid attributes are:'
        - ' - C(address) (str): The IPv6 address, for example, fc00:10:20:83:20c:29ff:fe94:bb5a.
            ([''set''])'
        - '   This key is required with [''set''].'
        - ' - C(prefix) (int): The IPv6 CIDR prefix, for example, 64. ([''set''])'
        - '   This key is required with [''set''].'
        elements: dict
        required: true
        type: list
    autoconf:
        description:
        - An address will be assigned by Stateless Address Autoconfiguration (SLAAC).
            This parameter is mandatory.
        required: true
        type: bool
    default_gateway:
        description:
        - The default gateway for static IP address assignment. This configures the
            global IPv6 default gateway on the appliance with the specified gateway
            address and interface. This gateway replaces the existing default gateway
            configured on the appliance. However, if the gateway address is link-local,
            then it is added for that interface. This does not support configuration
            of multiple global default gateways through different interfaces. This
            parameter is mandatory.
        required: true
        type: str
    dhcp:
        description:
        - An address will be assigned by a DHCP server. This parameter is mandatory.
        required: true
        type: bool
    interface_name:
        description:
        - Network interface to update, for example, "nic0".
        - The parameter must be the id of a resource returned by M(vmware.vmware_rest.appliance_networking_interfaces_info).
            This parameter is mandatory.
        required: true
        type: str
    session_timeout:
        description:
        - 'Timeout settings for client session. '
        - 'The maximal number of seconds for the whole operation including connection
            establishment, request sending and response. '
        - The default value is 300s.
        type: float
        version_added: 2.1.0
    state:
        choices:
        - set
        default: set
        description: []
        type: str
    vcenter_hostname:
        description:
        - The hostname or IP address of the vSphere vCenter
        - If the value is not specified in the task, the value of environment variable
            C(VMWARE_HOST) will be used instead.
        required: true
        type: str
    vcenter_password:
        description:
        - The vSphere vCenter password
        - If the value is not specified in the task, the value of environment variable
            C(VMWARE_PASSWORD) will be used instead.
        required: true
        type: str
    vcenter_rest_log_file:
        description:
        - 'You can use this optional parameter to set the location of a log file. '
        - 'This file will be used to record the HTTP REST interaction. '
        - 'The file will be stored on the host that runs the module. '
        - 'If the value is not specified in the task, the value of '
        - environment variable C(VMWARE_REST_LOG_FILE) will be used instead.
        type: str
    vcenter_username:
        description:
        - The vSphere vCenter username
        - If the value is not specified in the task, the value of environment variable
            C(VMWARE_USER) will be used instead.
        required: true
        type: str
    vcenter_validate_certs:
        default: true
        description:
        - Allows connection when SSL certificates are not valid. Set to C(false) when
            certificates are not trusted.
        - If the value is not specified in the task, the value of environment variable
            C(VMWARE_VALIDATE_CERTS) will be used instead.
        type: bool
author:
- Ansible Cloud Team (@ansible-collections)
version_added: 2.0.0
requirements:
- vSphere 7.0.3 or greater
- python >= 3.6
- aiohttp
notes:
- Tested on vSphere 7.0.3
"""

EXAMPLES = r"""
- name: Set the IPv6 network information of nic99 (which does not exist)
  vmware.vmware_rest.appliance_networking_interfaces_ipv6:
    interface_name: nic99
    mode: DHCP
  failed_when:
  - not(result.failed)
  - result.value.messages[0].default_message msg == "The interface is unknown."
  register: result
"""
RETURN = r"""
# content generated by the update_return_section callback# task: Set the IPv6 network information of nic99 (which does not exist)
failed_when_result:
  description: Set the IPv6 network information of nic99 (which does not exist)
  returned: On success
  sample: 0
  type: int
msg:
  description: Set the IPv6 network information of nic99 (which does not exist)
  returned: On success
  sample: 'missing required arguments: addresses, autoconf, default_gateway, dhcp'
  type: str
"""


# This structure describes the format of the data expected by the end-points
PAYLOAD_FORMAT = {
    "set": {
        "query": {},
        "body": {
            "addresses": "addresses",
            "autoconf": "autoconf",
            "default_gateway": "default_gateway",
            "dhcp": "dhcp",
        },
        "path": {"interface_name": "interface_name"},
    }
}  # pylint: disable=line-too-long

from ansible.module_utils.basic import env_fallback
import os

if os.getenv("VMWARE_ENABLE_TURBO", False):
    try:
        from ansible_collections.cloud.common.plugins.module_utils.turbo.exceptions import (
            EmbeddedModuleFailure,
        )
        from ansible_collections.cloud.common.plugins.module_utils.turbo.module import (
            AnsibleTurboModule as AnsibleModule,
        )

        AnsibleModule.collection_name = "vmware.vmware_rest"
    except ImportError:
        from ansible.module_utils.basic import AnsibleModule
else:
    from ansible.module_utils.basic import AnsibleModule

from ansible_collections.vmware.vmware_rest.plugins.module_utils.vmware_rest import (
    exists,
    gen_args,
    get_subdevice_type,
    open_session,
    prepare_payload,
    session_timeout,
    update_changed_flag,
)


def prepare_argument_spec():
    argument_spec = {
        "vcenter_hostname": dict(
            type="str",
            required=True,
            fallback=(env_fallback, ["VMWARE_HOST"]),
        ),
        "vcenter_username": dict(
            type="str",
            required=True,
            fallback=(env_fallback, ["VMWARE_USER"]),
        ),
        "vcenter_password": dict(
            type="str",
            required=True,
            no_log=True,
            fallback=(env_fallback, ["VMWARE_PASSWORD"]),
        ),
        "vcenter_validate_certs": dict(
            type="bool",
            required=False,
            default=True,
            fallback=(env_fallback, ["VMWARE_VALIDATE_CERTS"]),
        ),
        "vcenter_rest_log_file": dict(
            type="str",
            required=False,
            fallback=(env_fallback, ["VMWARE_REST_LOG_FILE"]),
        ),
        "session_timeout": dict(
            type="float",
            required=False,
            fallback=(env_fallback, ["VMWARE_SESSION_TIMEOUT"]),
        ),
    }

    argument_spec["addresses"] = {"required": True, "type": "list", "elements": "dict"}
    argument_spec["autoconf"] = {"required": True, "type": "bool"}
    argument_spec["default_gateway"] = {"required": True, "type": "str"}
    argument_spec["dhcp"] = {"required": True, "type": "bool"}
    argument_spec["interface_name"] = {"required": True, "type": "str"}
    argument_spec["state"] = {"type": "str", "choices": ["set"], "default": "set"}

    return argument_spec


async def main():
    required_if = list([])

    module_args = prepare_argument_spec()
    module = AnsibleModule(
        argument_spec=module_args, required_if=required_if, supports_check_mode=True
    )
    if not module.params["vcenter_hostname"]:
        module.fail_json("vcenter_hostname cannot be empty")
    if not module.params["vcenter_username"]:
        module.fail_json("vcenter_username cannot be empty")
    if not module.params["vcenter_password"]:
        module.fail_json("vcenter_password cannot be empty")
    try:
        session = await open_session(
            vcenter_hostname=module.params["vcenter_hostname"],
            vcenter_username=module.params["vcenter_username"],
            vcenter_password=module.params["vcenter_password"],
            validate_certs=module.params["vcenter_validate_certs"],
            log_file=module.params["vcenter_rest_log_file"],
        )
    except EmbeddedModuleFailure as err:
        module.fail_json(err.get_message())
    result = await entry_point(module, session)
    module.exit_json(**result)


# template: default_module.j2
def build_url(params):
    return (
        "https://{vcenter_hostname}"
        "/api/appliance/networking/interfaces/{interface_name}/ipv6"
    ).format(**params)


async def entry_point(module, session):

    if module.params["state"] == "present":
        if "_create" in globals():
            operation = "create"
        else:
            operation = "update"
    elif module.params["state"] == "absent":
        operation = "delete"
    else:
        operation = module.params["state"]

    func = globals()["_" + operation]

    return await func(module.params, session)


async def _set(params, session):
    _in_query_parameters = PAYLOAD_FORMAT["set"]["query"].keys()
    payload = prepare_payload(params, PAYLOAD_FORMAT["set"])
    subdevice_type = get_subdevice_type(
        "/api/appliance/networking/interfaces/{interface_name}/ipv6"
    )
    if subdevice_type and not params[subdevice_type]:
        _json = await exists(params, session, build_url(params))
        if _json:
            params[subdevice_type] = _json["id"]
    _url = (
        "https://{vcenter_hostname}"
        "/api/appliance/networking/interfaces/{interface_name}/ipv6"
    ).format(**params) + gen_args(params, _in_query_parameters)
    async with session.get(_url, json=payload, **session_timeout(params)) as resp:
        before = await resp.json()

    async with session.put(_url, json=payload, **session_timeout(params)) as resp:
        try:
            if resp.headers["Content-Type"] == "application/json":
                _json = await resp.json()
        except KeyError:
            _json = {}
        if "value" not in _json:  # 7.0.2
            _json = {"value": _json}

        # The PUT answer does not let us know if the resource has actually been
        # modified
        if resp.status < 300:
            async with session.get(
                _url, json=payload, **session_timeout(params)
            ) as resp_get:
                after = await resp_get.json()
                if before == after:
                    return await update_changed_flag(after, resp_get.status, "get")
        return await update_changed_flag(_json, resp.status, "set")


if __name__ == "__main__":
    import asyncio

    current_loop = asyncio.new_event_loop()
    try:
        asyncio.set_event_loop(current_loop)
        current_loop.run_until_complete(main())
    finally:
        current_loop.close()
